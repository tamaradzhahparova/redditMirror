webpackHotUpdate("main",{

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/header.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/header.css ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".header__example--QgiVa {\\n    color: blue;\\n}\\n\\n.header__style__second--2ud3Y {\\n    color: red;\\n}\", \"\"]);\n// Exports\nexports.locals = {\n\t\"example\": \"header__example--QgiVa\",\n\t\"style__second\": \"header__style__second--2ud3Y\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/header.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n    var list = []; // return the list of modules as css string\n    list.toString = function toString() {\n        return this.map(function (item) {\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join('');\n    }; // import a list of modules into the list\n    // eslint-disable-next-line func-names\n    list.i = function (modules, mediaQuery, dedupe) {\n        if (typeof modules === 'string') {\n            // eslint-disable-next-line no-param-reassign\n            modules = [[null, modules, '']];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for (var i = 0; i < this.length; i++) {\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for (var _i = 0; _i < modules.length; _i++) {\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                }\n                else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === 'function') {\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function (source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n        });\n        return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n    }\n    return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/fast-levenshtein/levenshtein.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-levenshtein/levenshtein.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;\n(function () {\n    'use strict';\n    var collator;\n    try {\n        collator = (typeof Intl !== \"undefined\" && typeof Intl.Collator !== \"undefined\") ? Intl.Collator(\"generic\", { sensitivity: \"base\" }) : null;\n    }\n    catch (err) {\n        console.log(\"Collator could not be initialized and wouldn't be used\");\n    }\n    // arrays to re-use\n    var prevRow = [], str2Char = [];\n    /**\n     * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\n     */\n    var Levenshtein = {\n        /**\n         * Calculate levenshtein distance of the two strings.\n         *\n         * @param str1 String the first string.\n         * @param str2 String the second string.\n         * @param [options] Additional options.\n         * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.\n         * @return Integer the levenshtein distance (0 and above).\n         */\n        get: function (str1, str2, options) {\n            var useCollator = (options && collator && options.useCollator);\n            var str1Len = str1.length, str2Len = str2.length;\n            // base cases\n            if (str1Len === 0)\n                return str2Len;\n            if (str2Len === 0)\n                return str1Len;\n            // two rows\n            var curCol, nextCol, i, j, tmp;\n            // initialise previous row\n            for (i = 0; i < str2Len; ++i) {\n                prevRow[i] = i;\n                str2Char[i] = str2.charCodeAt(i);\n            }\n            prevRow[str2Len] = str2Len;\n            var strCmp;\n            if (useCollator) {\n                // calculate current row distance from previous row using collator\n                for (i = 0; i < str1Len; ++i) {\n                    nextCol = i + 1;\n                    for (j = 0; j < str2Len; ++j) {\n                        curCol = nextCol;\n                        // substution\n                        strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));\n                        nextCol = prevRow[j] + (strCmp ? 0 : 1);\n                        // insertion\n                        tmp = curCol + 1;\n                        if (nextCol > tmp) {\n                            nextCol = tmp;\n                        }\n                        // deletion\n                        tmp = prevRow[j + 1] + 1;\n                        if (nextCol > tmp) {\n                            nextCol = tmp;\n                        }\n                        // copy current col value into previous (in preparation for next iteration)\n                        prevRow[j] = curCol;\n                    }\n                    // copy last col value into previous (in preparation for next iteration)\n                    prevRow[j] = nextCol;\n                }\n            }\n            else {\n                // calculate current row distance from previous row without collator\n                for (i = 0; i < str1Len; ++i) {\n                    nextCol = i + 1;\n                    for (j = 0; j < str2Len; ++j) {\n                        curCol = nextCol;\n                        // substution\n                        strCmp = str1.charCodeAt(i) === str2Char[j];\n                        nextCol = prevRow[j] + (strCmp ? 0 : 1);\n                        // insertion\n                        tmp = curCol + 1;\n                        if (nextCol > tmp) {\n                            nextCol = tmp;\n                        }\n                        // deletion\n                        tmp = prevRow[j + 1] + 1;\n                        if (nextCol > tmp) {\n                            nextCol = tmp;\n                        }\n                        // copy current col value into previous (in preparation for next iteration)\n                        prevRow[j] = curCol;\n                    }\n                    // copy last col value into previous (in preparation for next iteration)\n                    prevRow[j] = nextCol;\n                }\n            }\n            return nextCol;\n        }\n    };\n    // amd\n    if ( true && __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") !== null && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return Levenshtein;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // commonjs\n    else if ( true && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\n        module.exports = Levenshtein;\n    }\n    // web worker\n    else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\n        self.Levenshtein = Levenshtein;\n    }\n    // browser main thread\n    else if (typeof window !== \"undefined\" && window !== null) {\n        window.Levenshtein = Levenshtein;\n    }\n}());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/fast-levenshtein/levenshtein.js?");

/***/ }),

/***/ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar reactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    '$$typeof': true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    '$$typeof': true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\nfunction getStatics(component) {\n    // React v16.11 and below\n    if (reactIs.isMemo(component)) {\n        return MEMO_STATICS;\n    } // React v16.12 and above\n    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') {\n        // don't hoist over string (html) components\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n        var keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        var targetStatics = getStatics(targetComponent);\n        var sourceStatics = getStatics(sourceComponent);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    // Avoid failures from read-only properties\n                    defineProperty(targetComponent, key, descriptor);\n                }\n                catch (e) { }\n            }\n        }\n    }\n    return targetComponent;\n}\nmodule.exports = hoistNonReactStatics;\n\n\n//# sourceURL=webpack:///./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js?");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar printWarning = function () { };\nif (true) {\n    var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n    var loggedTypeFailures = {};\n    var has = Function.call.bind(Object.prototype.hasOwnProperty);\n    printWarning = function (text) {\n        var message = 'Warning: ' + text;\n        if (typeof console !== 'undefined') {\n            console.error(message);\n        }\n        try {\n            // --- Welcome to debugging React ---\n            // This error was thrown as a convenience so that you can use this stack\n            // to find the callsite that caused this warning to fire.\n            throw new Error(message);\n        }\n        catch (x) { }\n    };\n}\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n    if (true) {\n        for (var typeSpecName in typeSpecs) {\n            if (has(typeSpecs, typeSpecName)) {\n                var error;\n                // Prop type validation may throw. In case they do, we don't want to\n                // fail the render phase where it didn't fail before. So we log it.\n                // After these have been cleaned up, we'll let them throw.\n                try {\n                    // This is intentionally an invariant that gets caught. It's the same\n                    // behavior as without this statement except with a better message.\n                    if (typeof typeSpecs[typeSpecName] !== 'function') {\n                        var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n                            'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');\n                        err.name = 'Invariant Violation';\n                        throw err;\n                    }\n                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                }\n                catch (ex) {\n                    error = ex;\n                }\n                if (error && !(error instanceof Error)) {\n                    printWarning((componentName || 'React class') + ': type specification of ' +\n                        location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n                        'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n                        'You may have forgotten to pass an argument to the type checker ' +\n                        'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n                        'shape all require an argument).');\n                }\n                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                    // Only monitor this failure once because there tends to be a lot of the\n                    // same error.\n                    loggedTypeFailures[error.message] = true;\n                    var stack = getStack ? getStack() : '';\n                    printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));\n                }\n            }\n        }\n    }\n}\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function () {\n    if (true) {\n        loggedTypeFailures = {};\n    }\n};\nmodule.exports = checkPropTypes;\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/checkPropTypes.js?");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nvar printWarning = function () { };\nif (true) {\n    printWarning = function (text) {\n        var message = 'Warning: ' + text;\n        if (typeof console !== 'undefined') {\n            console.error(message);\n        }\n        try {\n            // --- Welcome to debugging React ---\n            // This error was thrown as a convenience so that you can use this stack\n            // to find the callsite that caused this warning to fire.\n            throw new Error(message);\n        }\n        catch (x) { }\n    };\n}\nfunction emptyFunctionThatReturnsNull() {\n    return null;\n}\nmodule.exports = function (isValidElement, throwOnDirectAccess) {\n    /* global Symbol */\n    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n    /**\n     * Returns the iterator method function contained on the iterable object.\n     *\n     * Be sure to invoke the function with the iterable as context:\n     *\n     *     var iteratorFn = getIteratorFn(myIterable);\n     *     if (iteratorFn) {\n     *       var iterator = iteratorFn.call(myIterable);\n     *       ...\n     *     }\n     *\n     * @param {?object} maybeIterable\n     * @return {?function}\n     */\n    function getIteratorFn(maybeIterable) {\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n        if (typeof iteratorFn === 'function') {\n            return iteratorFn;\n        }\n    }\n    /**\n     * Collection of methods that allow declaration and validation of props that are\n     * supplied to React components. Example usage:\n     *\n     *   var Props = require('ReactPropTypes');\n     *   var MyArticle = React.createClass({\n     *     propTypes: {\n     *       // An optional string prop named \"description\".\n     *       description: Props.string,\n     *\n     *       // A required enum prop named \"category\".\n     *       category: Props.oneOf(['News','Photos']).isRequired,\n     *\n     *       // A prop named \"dialog\" that requires an instance of Dialog.\n     *       dialog: Props.instanceOf(Dialog).isRequired\n     *     },\n     *     render: function() { ... }\n     *   });\n     *\n     * A more formal specification of how these methods are used:\n     *\n     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n     *   decl := ReactPropTypes.{type}(.isRequired)?\n     *\n     * Each and every declaration produces a function with the same signature. This\n     * allows the creation of custom validation functions. For example:\n     *\n     *  var MyLink = React.createClass({\n     *    propTypes: {\n     *      // An optional string or URI prop named \"href\".\n     *      href: function(props, propName, componentName) {\n     *        var propValue = props[propName];\n     *        if (propValue != null && typeof propValue !== 'string' &&\n     *            !(propValue instanceof URI)) {\n     *          return new Error(\n     *            'Expected a string or an URI for ' + propName + ' in ' +\n     *            componentName\n     *          );\n     *        }\n     *      }\n     *    },\n     *    render: function() {...}\n     *  });\n     *\n     * @internal\n     */\n    var ANONYMOUS = '<<anonymous>>';\n    // Important!\n    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n    var ReactPropTypes = {\n        array: createPrimitiveTypeChecker('array'),\n        bool: createPrimitiveTypeChecker('boolean'),\n        func: createPrimitiveTypeChecker('function'),\n        number: createPrimitiveTypeChecker('number'),\n        object: createPrimitiveTypeChecker('object'),\n        string: createPrimitiveTypeChecker('string'),\n        symbol: createPrimitiveTypeChecker('symbol'),\n        any: createAnyTypeChecker(),\n        arrayOf: createArrayOfTypeChecker,\n        element: createElementTypeChecker(),\n        elementType: createElementTypeTypeChecker(),\n        instanceOf: createInstanceTypeChecker,\n        node: createNodeChecker(),\n        objectOf: createObjectOfTypeChecker,\n        oneOf: createEnumTypeChecker,\n        oneOfType: createUnionTypeChecker,\n        shape: createShapeTypeChecker,\n        exact: createStrictShapeTypeChecker,\n    };\n    /**\n     * inlined Object.is polyfill to avoid requiring consumers ship their own\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n     */\n    /*eslint-disable no-self-compare*/\n    function is(x, y) {\n        // SameValue algorithm\n        if (x === y) {\n            // Steps 1-5, 7-10\n            // Steps 6.b-6.e: +0 != -0\n            return x !== 0 || 1 / x === 1 / y;\n        }\n        else {\n            // Step 6.a: NaN == NaN\n            return x !== x && y !== y;\n        }\n    }\n    /*eslint-enable no-self-compare*/\n    /**\n     * We use an Error-like object for backward compatibility as people may call\n     * PropTypes directly and inspect their output. However, we don't use real\n     * Errors anymore. We don't inspect their stack anyway, and creating them\n     * is prohibitively expensive if they are created too often, such as what\n     * happens in oneOfType() for any type before the one that matched.\n     */\n    function PropTypeError(message) {\n        this.message = message;\n        this.stack = '';\n    }\n    // Make `instanceof Error` still work for returned errors.\n    PropTypeError.prototype = Error.prototype;\n    function createChainableTypeChecker(validate) {\n        if (true) {\n            var manualPropTypeCallCache = {};\n            var manualPropTypeWarningCount = 0;\n        }\n        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n            componentName = componentName || ANONYMOUS;\n            propFullName = propFullName || propName;\n            if (secret !== ReactPropTypesSecret) {\n                if (throwOnDirectAccess) {\n                    // New behavior only for users of `prop-types` package\n                    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n                        'Use `PropTypes.checkPropTypes()` to call them. ' +\n                        'Read more at http://fb.me/use-check-prop-types');\n                    err.name = 'Invariant Violation';\n                    throw err;\n                }\n                else if ( true && typeof console !== 'undefined') {\n                    // Old behavior for people using React.PropTypes\n                    var cacheKey = componentName + ':' + propName;\n                    if (!manualPropTypeCallCache[cacheKey] &&\n                        // Avoid spamming the console because they are often not actionable except for lib authors\n                        manualPropTypeWarningCount < 3) {\n                        printWarning('You are manually calling a React.PropTypes validation ' +\n                            'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n                            'and will throw in the standalone `prop-types` package. ' +\n                            'You may be seeing this warning due to a third-party PropTypes ' +\n                            'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');\n                        manualPropTypeCallCache[cacheKey] = true;\n                        manualPropTypeWarningCount++;\n                    }\n                }\n            }\n            if (props[propName] == null) {\n                if (isRequired) {\n                    if (props[propName] === null) {\n                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n                    }\n                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n                }\n                return null;\n            }\n            else {\n                return validate(props, propName, componentName, location, propFullName);\n            }\n        }\n        var chainedCheckType = checkType.bind(null, false);\n        chainedCheckType.isRequired = checkType.bind(null, true);\n        return chainedCheckType;\n    }\n    function createPrimitiveTypeChecker(expectedType) {\n        function validate(props, propName, componentName, location, propFullName, secret) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== expectedType) {\n                // `propValue` being instance of, say, date/regexp, pass the 'object'\n                // check, but we can offer a more precise error message here rather than\n                // 'of type `object`'.\n                var preciseType = getPreciseType(propValue);\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createAnyTypeChecker() {\n        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n    }\n    function createArrayOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== 'function') {\n                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n            }\n            var propValue = props[propName];\n            if (!Array.isArray(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n            }\n            for (var i = 0; i < propValue.length; i++) {\n                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n                if (error instanceof Error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createElementTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            if (!isValidElement(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createElementTypeTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            if (!ReactIs.isValidElementType(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createInstanceTypeChecker(expectedClass) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (!(props[propName] instanceof expectedClass)) {\n                var expectedClassName = expectedClass.name || ANONYMOUS;\n                var actualClassName = getClassName(props[propName]);\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createEnumTypeChecker(expectedValues) {\n        if (!Array.isArray(expectedValues)) {\n            if (true) {\n                if (arguments.length > 1) {\n                    printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n                        'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');\n                }\n                else {\n                    printWarning('Invalid argument supplied to oneOf, expected an array.');\n                }\n            }\n            return emptyFunctionThatReturnsNull;\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            for (var i = 0; i < expectedValues.length; i++) {\n                if (is(propValue, expectedValues[i])) {\n                    return null;\n                }\n            }\n            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n                var type = getPreciseType(value);\n                if (type === 'symbol') {\n                    return String(value);\n                }\n                return value;\n            });\n            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createObjectOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== 'function') {\n                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n            }\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== 'object') {\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n            }\n            for (var key in propValue) {\n                if (has(propValue, key)) {\n                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n                    if (error instanceof Error) {\n                        return error;\n                    }\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createUnionTypeChecker(arrayOfTypeCheckers) {\n        if (!Array.isArray(arrayOfTypeCheckers)) {\n             true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\n            return emptyFunctionThatReturnsNull;\n        }\n        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n            var checker = arrayOfTypeCheckers[i];\n            if (typeof checker !== 'function') {\n                printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n                    'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');\n                return emptyFunctionThatReturnsNull;\n            }\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n                var checker = arrayOfTypeCheckers[i];\n                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                    return null;\n                }\n            }\n            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createNodeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (!isNode(props[propName])) {\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== 'object') {\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n            }\n            for (var key in shapeTypes) {\n                var checker = shapeTypes[key];\n                if (!checker) {\n                    continue;\n                }\n                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n                if (error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createStrictShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== 'object') {\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n            }\n            // We need to check all keys in case some are required but missing from\n            // props.\n            var allKeys = assign({}, props[propName], shapeTypes);\n            for (var key in allKeys) {\n                var checker = shapeTypes[key];\n                if (!checker) {\n                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n                        '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n                        '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));\n                }\n                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n                if (error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function isNode(propValue) {\n        switch (typeof propValue) {\n            case 'number':\n            case 'string':\n            case 'undefined':\n                return true;\n            case 'boolean':\n                return !propValue;\n            case 'object':\n                if (Array.isArray(propValue)) {\n                    return propValue.every(isNode);\n                }\n                if (propValue === null || isValidElement(propValue)) {\n                    return true;\n                }\n                var iteratorFn = getIteratorFn(propValue);\n                if (iteratorFn) {\n                    var iterator = iteratorFn.call(propValue);\n                    var step;\n                    if (iteratorFn !== propValue.entries) {\n                        while (!(step = iterator.next()).done) {\n                            if (!isNode(step.value)) {\n                                return false;\n                            }\n                        }\n                    }\n                    else {\n                        // Iterator will provide entry [k,v] tuples rather than values.\n                        while (!(step = iterator.next()).done) {\n                            var entry = step.value;\n                            if (entry) {\n                                if (!isNode(entry[1])) {\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    return false;\n                }\n                return true;\n            default:\n                return false;\n        }\n    }\n    function isSymbol(propType, propValue) {\n        // Native Symbol.\n        if (propType === 'symbol') {\n            return true;\n        }\n        // falsy value can't be a Symbol\n        if (!propValue) {\n            return false;\n        }\n        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n        if (propValue['@@toStringTag'] === 'Symbol') {\n            return true;\n        }\n        // Fallback for non-spec compliant Symbols which are polyfilled.\n        if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n            return true;\n        }\n        return false;\n    }\n    // Equivalent of `typeof` but with special handling for array and regexp.\n    function getPropType(propValue) {\n        var propType = typeof propValue;\n        if (Array.isArray(propValue)) {\n            return 'array';\n        }\n        if (propValue instanceof RegExp) {\n            // Old webkits (at least until Android 4.0) return 'function' rather than\n            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n            // passes PropTypes.object.\n            return 'object';\n        }\n        if (isSymbol(propType, propValue)) {\n            return 'symbol';\n        }\n        return propType;\n    }\n    // This handles more types than `getPropType`. Only used for error messages.\n    // See `createPrimitiveTypeChecker`.\n    function getPreciseType(propValue) {\n        if (typeof propValue === 'undefined' || propValue === null) {\n            return '' + propValue;\n        }\n        var propType = getPropType(propValue);\n        if (propType === 'object') {\n            if (propValue instanceof Date) {\n                return 'date';\n            }\n            else if (propValue instanceof RegExp) {\n                return 'regexp';\n            }\n        }\n        return propType;\n    }\n    // Returns a string that is postfixed to a warning about an invalid type.\n    // For example, \"undefined\" or \"of type array\"\n    function getPostfixForTypeWarning(value) {\n        var type = getPreciseType(value);\n        switch (type) {\n            case 'array':\n            case 'object':\n                return 'an ' + type;\n            case 'boolean':\n            case 'date':\n            case 'regexp':\n                return 'a ' + type;\n            default:\n                return type;\n        }\n    }\n    // Returns class name of the object, if any.\n    function getClassName(propValue) {\n        if (!propValue.constructor || !propValue.constructor.name) {\n            return ANONYMOUS;\n        }\n        return propValue.constructor.name;\n    }\n    ReactPropTypes.checkPropTypes = checkPropTypes;\n    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n    ReactPropTypes.PropTypes = ReactPropTypes;\n    return ReactPropTypes;\n};\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/factoryWithTypeCheckers.js?");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nif (true) {\n    var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n    // By explicitly using `prop-types` you are opting into new development behavior.\n    // http://fb.me/prop-types-in-prod\n    var throwOnDirectAccess = true;\n    module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n}\nelse {}\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/index.js?");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\nmodule.exports = ReactPropTypesSecret;\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js?");

/***/ }),

/***/ "./node_modules/react-hot-loader/dist/react-hot-loader.development.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-hot-loader/dist/react-hot-loader.development.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction _interopDefault(ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar React__default = _interopDefault(React);\nvar shallowEqual = _interopDefault(__webpack_require__(/*! shallowequal */ \"./node_modules/shallowequal/index.js\"));\nvar levenshtein = _interopDefault(__webpack_require__(/*! fast-levenshtein */ \"./node_modules/fast-levenshtein/levenshtein.js\"));\nvar ReactDOM = _interopDefault(__webpack_require__(/*! react-dom */ \"./node_modules/@hot-loader/react-dom/index.js\"));\nvar PropTypes = _interopDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\nvar defaultPolyfill = __webpack_require__(/*! react-lifecycles-compat */ \"./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\");\nvar defaultPolyfill__default = _interopDefault(defaultPolyfill);\nvar hoistNonReactStatic = _interopDefault(__webpack_require__(/*! hoist-non-react-statics */ \"./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\"));\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n} : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n};\nvar _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n};\nvar inherits = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass)\n        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\nvar possibleConstructorReturn = function (self, call) {\n    if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/* eslint-disable no-underscore-dangle */\nvar isCompositeComponent = function isCompositeComponent(type) {\n    return typeof type === 'function';\n};\nvar isReloadableComponent = function isReloadableComponent(type) {\n    return typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object';\n};\nvar getComponentDisplayName = function getComponentDisplayName(type) {\n    var displayName = type.displayName || type.name;\n    return displayName && displayName !== 'ReactComponent' ? displayName : 'Component';\n};\nvar reactLifeCycleMountMethods = ['componentWillMount', 'componentDidMount'];\nfunction isReactClass(Component) {\n    return !!(Component.prototype && (React__default.Component.prototype.isPrototypeOf(Component.prototype) ||\n        // react 14 support\n        Component.prototype.isReactComponent || Component.prototype.componentWillMount || Component.prototype.componentWillUnmount || Component.prototype.componentDidMount || Component.prototype.componentDidUnmount || Component.prototype.render));\n}\nfunction isReactClassInstance(Component) {\n    return Component && isReactClass({ prototype: Object.getPrototypeOf(Component) });\n}\nvar getInternalInstance = function getInternalInstance(instance) {\n    return instance._reactInternalFiber || // React 16\n        instance._reactInternalInstance || // React 15\n        null;\n};\nvar updateInstance = function updateInstance(instance) {\n    var updater = instance.updater, forceUpdate = instance.forceUpdate;\n    if (typeof forceUpdate === 'function') {\n        instance.forceUpdate();\n    }\n    else if (updater && typeof updater.enqueueForceUpdate === 'function') {\n        updater.enqueueForceUpdate(instance);\n    }\n};\nvar isFragmentNode = function isFragmentNode(_ref) {\n    var type = _ref.type;\n    return React__default.Fragment && type === React__default.Fragment;\n};\nvar ContextType = React__default.createContext ? React__default.createContext() : null;\nvar ConsumerType = ContextType && ContextType.Consumer.$$typeof;\nvar ProviderType = ContextType && ContextType.Provider.$$typeof;\nvar MemoType = React__default.memo && React__default.memo(function () {\n    return null;\n}).$$typeof;\nvar LazyType = React__default.lazy && React__default.lazy(function () {\n    return null;\n}).$$typeof;\nvar ForwardType = React__default.forwardRef && React__default.forwardRef(function () {\n    return null;\n}).$$typeof;\nvar CONTEXT_CURRENT_VALUE = '_currentValue';\nvar isContextConsumer = function isContextConsumer(_ref2) {\n    var type = _ref2.type;\n    return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ConsumerType && ConsumerType;\n};\nvar isContextProvider = function isContextProvider(_ref3) {\n    var type = _ref3.type;\n    return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ProviderType && ProviderType;\n};\nvar isMemoType = function isMemoType(_ref4) {\n    var type = _ref4.type;\n    return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === MemoType && MemoType;\n};\nvar isLazyType = function isLazyType(_ref5) {\n    var type = _ref5.type;\n    return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === LazyType && LazyType;\n};\nvar isForwardType = function isForwardType(_ref6) {\n    var type = _ref6.type;\n    return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ForwardType && ForwardType;\n};\nvar isContextType = function isContextType(type) {\n    return isContextConsumer(type) || isContextProvider(type);\n};\nvar getElementType = function getElementType(type) {\n    var element = { type: type };\n    if (isContextConsumer(element)) {\n        return 'Consumer';\n    }\n    if (isContextProvider(element)) {\n        return 'Provider';\n    }\n    if (isLazyType(element)) {\n        return 'Lazy';\n    }\n    if (isMemoType(element)) {\n        return 'Memo';\n    }\n    if (isForwardType(element)) {\n        return 'Forward';\n    }\n    if (isReactClass(type)) {\n        return 'Class';\n    }\n    if (typeof element === 'function') {\n        return 'FC';\n    }\n    return 'unknown';\n};\nvar getContextProvider = function getContextProvider(type) {\n    return type && type._context;\n};\nvar configuration = {\n    // Log level\n    logLevel: 'error',\n    // Allows using SFC without changes\n    pureSFC: true,\n    // keep render method unpatched, moving sideEffect to componentDidUpdate\n    pureRender: true,\n    // Allows SFC to be used, enables \"intermediate\" components used by Relay, should be disabled for Preact\n    allowSFC: true,\n    // Allow reload of effect hooks with non zero dependency list\n    reloadHooks: true,\n    // Allow reload of mount effect hooks - zero deps\n    reloadLifeCycleHooks: false,\n    // Enables hook reload on hook body change\n    reloadHooksOnBodyChange: true,\n    // Disable \"hot-replacement-render\"\n    disableHotRenderer: false,\n    // @private\n    integratedComparator: false,\n    // @private\n    integratedResolver: false,\n    // Disable \"hot-replacement-render\" when injection into react-dom is made\n    disableHotRendererWhenInjected: true,\n    // Controls `react-🔥-dom patch` notification\n    showReactDomPatchNotification: true,\n    // Hook on babel component register.\n    onComponentRegister: false,\n    // Hook on React renders for a first time component\n    onComponentCreate: false,\n    // flag to completely disable RHL for SFC. Probably don't use it without dom patch made.\n    ignoreSFC: false,\n    // ignoreSFC when injection into react-dom is made\n    ignoreSFCWhenInjected: true,\n    // flag to completely disable RHL for Components\n    ignoreComponents: false,\n    // default value for AppContainer errorOverlay\n    errorReporter: undefined,\n    // Global error overlay\n    ErrorOverlay: undefined,\n    // Actively track lazy loaded components\n    trackTailUpdates: true,\n    // wrap lazy with AppProvider to allow independent updates\n    wrapLazy: true,\n    // react hot dom features enabled\n    IS_REACT_MERGE_ENABLED: false\n};\nvar internalConfiguration = {\n    // control proxy creation\n    disableProxyCreation: false\n};\nvar setConfiguration = function setConfiguration(config) {\n    // not using Object.assing for IE11 compliance\n    for (var i in config) {\n        if (config.hasOwnProperty(i)) {\n            configuration[i] = config[i];\n        }\n    }\n};\n/* eslint-disable no-console */\nvar logger = {\n    debug: function debug() {\n        if (['debug'].indexOf(configuration.logLevel) !== -1) {\n            var _console;\n            (_console = console).debug.apply(_console, arguments);\n        }\n    },\n    log: function log() {\n        if (['debug', 'log'].indexOf(configuration.logLevel) !== -1) {\n            var _console2;\n            (_console2 = console).log.apply(_console2, arguments);\n        }\n    },\n    warn: function warn() {\n        if (['debug', 'log', 'warn'].indexOf(configuration.logLevel) !== -1) {\n            var _console3;\n            (_console3 = console).warn.apply(_console3, arguments);\n        }\n    },\n    error: function error() {\n        if (['debug', 'log', 'warn', 'error'].indexOf(configuration.logLevel) !== -1) {\n            var _console4;\n            (_console4 = console).error.apply(_console4, arguments);\n        }\n    }\n};\n/* eslint-disable no-eval, func-names */\nfunction safeReactConstructor(Component, lastInstance) {\n    try {\n        if (lastInstance) {\n            return new Component(lastInstance.props, lastInstance.context);\n        }\n        return new Component({}, {});\n    }\n    catch (e) {\n        // some components, like Redux connect could not be created without proper context\n    }\n    return null;\n}\nfunction isNativeFunction(fn) {\n    return typeof fn === 'function' ? fn.toString().indexOf('[native code]') > 0 : false;\n}\nvar identity = function identity(a) {\n    return a;\n};\nvar indirectEval = eval;\nvar doesSupportClasses = function () {\n    try {\n        indirectEval('class Test {}');\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}();\nvar ES6ProxyComponentFactory = function ES6ProxyComponentFactory(InitialParent, postConstructionAction) {\n    return indirectEval('\\n(function(InitialParent, postConstructionAction) {\\n  return class ' + (InitialParent.name || 'HotComponent') + ' extends InitialParent {\\n    /*\\n     ! THIS IS NOT YOUR COMPONENT !\\n     !  THIS IS REACT-HOT-LOADER  !\\n  \\n     this is a \"' + InitialParent.name + '\" component, patched by React-Hot-Loader\\n     Sorry, but the real class code was hidden behind this facade\\n     Please refer to https://github.com/gaearon/react-hot-loader for details...\\n    */    \\n    \\n    constructor(props, context) {\\n      super(props, context)\\n      postConstructionAction.call(this)\\n    }\\n  }\\n})\\n')(InitialParent, postConstructionAction);\n};\nvar ES5ProxyComponentFactory = function ES5ProxyComponentFactory(InitialParent, postConstructionAction) {\n    function ProxyComponent(props, context) {\n        InitialParent.call(this, props, context);\n        postConstructionAction.call(this);\n    }\n    ProxyComponent.prototype = Object.create(InitialParent.prototype);\n    Object.setPrototypeOf(ProxyComponent, InitialParent);\n    return ProxyComponent;\n};\nvar proxyClassCreator = doesSupportClasses ? ES6ProxyComponentFactory : ES5ProxyComponentFactory;\nfunction getOwnKeys(target) {\n    return [].concat(Object.getOwnPropertyNames(target), Object.getOwnPropertySymbols(target));\n}\nfunction shallowStringsEqual(a, b) {\n    for (var key in a) {\n        if (String(a[key]) !== String(b[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction deepPrototypeUpdate(dest, source) {\n    var deepDest = Object.getPrototypeOf(dest);\n    var deepSrc = Object.getPrototypeOf(source);\n    if (deepDest && deepSrc && deepSrc !== deepDest) {\n        deepPrototypeUpdate(deepDest, deepSrc);\n    }\n    if (source.prototype && source.prototype !== dest.prototype) {\n        dest.prototype = source.prototype;\n    }\n}\nfunction safeDefineProperty(target, key, props) {\n    try {\n        Object.defineProperty(target, key, props);\n    }\n    catch (e) {\n        logger.warn('Error while wrapping', key, ' -> ', e);\n    }\n}\nvar PREFIX = '__reactstandin__';\nvar PROXY_KEY = PREFIX + 'key';\nvar GENERATION = PREFIX + 'proxyGeneration';\nvar REGENERATE_METHOD = PREFIX + 'regenerateByEval';\nvar UNWRAP_PROXY = PREFIX + 'getCurrent';\nvar CACHED_RESULT = PREFIX + 'cachedResult';\nvar PROXY_IS_MOUNTED = PREFIX + 'isMounted';\nvar RENDERED_GENERATION = 'REACT_HOT_LOADER_RENDERED_GENERATION';\nvar RESERVED_STATICS = ['length', 'displayName', 'name', 'arguments', 'caller', 'prototype', 'toString', 'valueOf', 'isStatelessFunctionalProxy', PROXY_KEY, UNWRAP_PROXY];\nfunction transferStaticProps(ProxyComponent, savedDescriptors, PreviousComponent, NextComponent) {\n    Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {\n        if (RESERVED_STATICS.indexOf(key) !== -1) {\n            return;\n        }\n        var prevDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);\n        var savedDescriptor = savedDescriptors[key];\n        if (!shallowEqual(prevDescriptor, savedDescriptor)) {\n            safeDefineProperty(NextComponent, key, prevDescriptor);\n        }\n    });\n    // Copy newly defined static methods and properties\n    Object.getOwnPropertyNames(NextComponent).forEach(function (key) {\n        if (RESERVED_STATICS.indexOf(key) !== -1) {\n            return;\n        }\n        var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(ProxyComponent, key);\n        var savedDescriptor = savedDescriptors[key];\n        // Skip redefined descriptors\n        if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {\n            safeDefineProperty(NextComponent, key, prevDescriptor);\n            return;\n        }\n        if (prevDescriptor && !savedDescriptor) {\n            safeDefineProperty(ProxyComponent, key, prevDescriptor);\n            return;\n        }\n        var nextDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextComponent, key), {\n            configurable: true\n        });\n        savedDescriptors[key] = nextDescriptor;\n        safeDefineProperty(ProxyComponent, key, nextDescriptor);\n    });\n    // Remove static methods and properties that are no longer defined\n    Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {\n        if (RESERVED_STATICS.indexOf(key) !== -1) {\n            return;\n        }\n        // Skip statics that exist on the next class\n        if (NextComponent.hasOwnProperty(key)) {\n            return;\n        }\n        // Skip non-configurable statics\n        var proxyDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);\n        if (proxyDescriptor && !proxyDescriptor.configurable) {\n            return;\n        }\n        var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(PreviousComponent, key);\n        var savedDescriptor = savedDescriptors[key];\n        // Skip redefined descriptors\n        if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {\n            return;\n        }\n        safeDefineProperty(ProxyComponent, key, {\n            value: undefined\n        });\n    });\n    return savedDescriptors;\n}\nfunction mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers) {\n    var injectedCode = {};\n    try {\n        var nextInstance = safeReactConstructor(NextComponent, lastInstance);\n        try {\n            // Bypass babel class inheritance checking\n            deepPrototypeUpdate(InitialComponent, NextComponent);\n        }\n        catch (e) {\n            // It was ES6 class\n        }\n        var proxyInstance = safeReactConstructor(ProxyComponent, lastInstance);\n        if (!nextInstance || !proxyInstance) {\n            return injectedCode;\n        }\n        var mergedAttrs = _extends({}, proxyInstance, nextInstance);\n        var hasRegenerate = proxyInstance[REGENERATE_METHOD];\n        var ownKeys = getOwnKeys(Object.getPrototypeOf(ProxyComponent.prototype));\n        Object.keys(mergedAttrs).forEach(function (key) {\n            if (key.indexOf(PREFIX) === 0)\n                return;\n            var nextAttr = nextInstance[key];\n            var prevAttr = proxyInstance[key];\n            if (nextAttr) {\n                if (isNativeFunction(nextAttr) || isNativeFunction(prevAttr)) {\n                    // this is bound method\n                    var isSameArity = nextAttr.length === prevAttr.length;\n                    var existsInPrototype = ownKeys.indexOf(key) >= 0 || ProxyComponent.prototype[key];\n                    if ((isSameArity || !prevAttr) && existsInPrototype) {\n                        if (hasRegenerate) {\n                            injectedCode[key] = 'Object.getPrototypeOf(this)[\\'' + key + '\\'].bind(this)';\n                        }\n                        else {\n                            logger.warn('React Hot Loader:,', 'Non-controlled class', ProxyComponent.name, 'contains a new native or bound function ', key, nextAttr, '. Unable to reproduce');\n                        }\n                    }\n                    else {\n                        logger.warn('React Hot Loader:', 'Updated class ', ProxyComponent.name, 'contains native or bound function ', key, nextAttr, '. Unable to reproduce, use arrow functions instead.', '(arity: ' + nextAttr.length + '/' + prevAttr.length + ', proto: ' + (existsInPrototype ? 'yes' : 'no'));\n                    }\n                    return;\n                }\n                var nextString = String(nextAttr);\n                var injectedBefore = injectedMembers[key];\n                var isArrow = nextString.indexOf('=>') >= 0;\n                var isFunction = nextString.indexOf('function') >= 0 || isArrow;\n                var referToThis = nextString.indexOf('this') >= 0;\n                if (nextString !== String(prevAttr) || injectedBefore && nextString !== String(injectedBefore) || isArrow && referToThis) {\n                    if (!hasRegenerate) {\n                        if (!isFunction) {\n                            // just copy prop over\n                            injectedCode[key] = nextAttr;\n                        }\n                        else {\n                            logger.warn('React Hot Loader:', ' Updated class ', ProxyComponent.name, 'had different code for', key, nextAttr, '. Unable to reproduce. Regeneration support needed.');\n                        }\n                    }\n                    else {\n                        injectedCode[key] = nextAttr;\n                    }\n                }\n            }\n        });\n    }\n    catch (e) {\n        logger.warn('React Hot Loader:', e);\n    }\n    return injectedCode;\n}\nfunction checkLifeCycleMethods(ProxyComponent, NextComponent) {\n    try {\n        var p1 = Object.getPrototypeOf(ProxyComponent.prototype);\n        var p2 = NextComponent.prototype;\n        reactLifeCycleMountMethods.forEach(function (key) {\n            var d1 = Object.getOwnPropertyDescriptor(p1, key) || { value: p1[key] };\n            var d2 = Object.getOwnPropertyDescriptor(p2, key) || { value: p2[key] };\n            if (!shallowStringsEqual(d1, d2)) {\n                logger.warn('React Hot Loader:', 'You did update', ProxyComponent.name, 's lifecycle method', key, '. Unable to repeat');\n            }\n        });\n    }\n    catch (e) {\n        // Ignore errors\n    }\n}\nfunction inject(target, currentGeneration, injectedMembers) {\n    if (target[GENERATION] !== currentGeneration) {\n        var hasRegenerate = !!target[REGENERATE_METHOD];\n        Object.keys(injectedMembers).forEach(function (key) {\n            try {\n                if (hasRegenerate) {\n                    var usedThis = String(injectedMembers[key]).match(/_this([\\d]+)/gi) || [];\n                    target[REGENERATE_METHOD](key, '(function REACT_HOT_LOADER_SANDBOX () {\\n          var _this  = this; // common babel transpile\\n          ' + usedThis.map(function (name) {\n                        return 'var ' + name + ' = this;';\n                    }) + '\\n\\n          return ' + injectedMembers[key] + ';\\n          }).call(this)');\n                }\n                else {\n                    target[key] = injectedMembers[key];\n                }\n            }\n            catch (e) {\n                logger.warn('React Hot Loader: Failed to regenerate method ', key, ' of class ', target);\n                logger.warn('got error', e);\n            }\n        });\n        target[GENERATION] = currentGeneration;\n    }\n}\nvar has = Object.prototype.hasOwnProperty;\nvar proxies = new WeakMap();\nvar resetClassProxies = function resetClassProxies() {\n    proxies = new WeakMap();\n};\nvar blackListedClassMembers = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentDidCatch', 'componentWillReceiveProps', 'componentWillUnmount', 'hotComponentRender', 'getInitialState', 'getDefaultProps'];\nvar defaultRenderOptions = {\n    componentWillRender: identity,\n    componentDidUpdate: function componentDidUpdate(result) {\n        return result;\n    },\n    componentDidRender: function componentDidRender(result) {\n        return result;\n    }\n};\nvar filteredPrototypeMethods = function filteredPrototypeMethods(Proto) {\n    return Object.getOwnPropertyNames(Proto).filter(function (prop) {\n        var descriptor = Object.getOwnPropertyDescriptor(Proto, prop);\n        return descriptor && prop.indexOf(PREFIX) !== 0 && blackListedClassMembers.indexOf(prop) < 0 && typeof descriptor.value === 'function';\n    });\n};\nvar defineClassMember = function defineClassMember(Class, methodName, methodBody) {\n    return safeDefineProperty(Class.prototype, methodName, {\n        configurable: true,\n        writable: true,\n        enumerable: false,\n        value: methodBody\n    });\n};\nvar defineClassMembers = function defineClassMembers(Class, methods) {\n    return Object.keys(methods).forEach(function (methodName) {\n        return defineClassMember(Class, methodName, methods[methodName]);\n    });\n};\nvar setSFPFlag = function setSFPFlag(component, flag) {\n    return safeDefineProperty(component, 'isStatelessFunctionalProxy', {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: flag\n    });\n};\nvar copyMethodDescriptors = function copyMethodDescriptors(target, source) {\n    if (source) {\n        // it is possible to use `function-double` to construct an ideal clone, but does not make a sence\n        var keys = Object.getOwnPropertyNames(source);\n        keys.forEach(function (key) {\n            return safeDefineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n        safeDefineProperty(target, 'toString', {\n            configurable: true,\n            writable: false,\n            enumerable: false,\n            value: function toString() {\n                return String(source);\n            }\n        });\n    }\n    return target;\n};\nvar knownClassComponents = [];\nvar forEachKnownClass = function forEachKnownClass(cb) {\n    return knownClassComponents.forEach(cb);\n};\nfunction createClassProxy(InitialComponent, proxyKey) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var renderOptions = _extends({}, defaultRenderOptions, options);\n    var proxyConfig = _extends({}, configuration, options.proxy);\n    // Prevent double wrapping.\n    // Given a proxy class, return the existing proxy managing it.\n    var existingProxy = proxies.get(InitialComponent);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    var CurrentComponent = void 0;\n    var savedDescriptors = {};\n    var injectedMembers = {};\n    var proxyGeneration = 0;\n    var classUpdatePostponed = null;\n    var instancesCount = 0;\n    var isFunctionalComponent = !isReactClass(InitialComponent);\n    var lastInstance = null;\n    function postConstructionAction() {\n        this[GENERATION] = 0;\n        lastInstance = this;\n        // is there is an update pending\n        if (classUpdatePostponed) {\n            var callUpdate = classUpdatePostponed;\n            classUpdatePostponed = null;\n            callUpdate();\n        }\n        // As long we can't override constructor\n        // every class shall evolve from a base class\n        inject(this, proxyGeneration, injectedMembers);\n    }\n    function proxiedUpdate() {\n        if (this) {\n            inject(this, proxyGeneration, injectedMembers);\n        }\n    }\n    function lifeCycleWrapperFactory(wrapperName) {\n        var sideEffect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n        return copyMethodDescriptors(function wrappedMethod() {\n            proxiedUpdate.call(this);\n            sideEffect(this);\n            for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {\n                rest[_key] = arguments[_key];\n            }\n            return !isFunctionalComponent && CurrentComponent.prototype[wrapperName] && CurrentComponent.prototype[wrapperName].apply(this, rest);\n        }, InitialComponent.prototype && InitialComponent.prototype[wrapperName]);\n    }\n    function methodWrapperFactory(wrapperName, realMethod) {\n        return copyMethodDescriptors(function wrappedMethod() {\n            for (var _len2 = arguments.length, rest = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                rest[_key2] = arguments[_key2];\n            }\n            return realMethod.apply(this, rest);\n        }, realMethod);\n    }\n    var fakeBasePrototype = function fakeBasePrototype(Proto) {\n        return filteredPrototypeMethods(Proto).reduce(function (acc, key) {\n            acc[key] = methodWrapperFactory(key, Proto[key]);\n            return acc;\n        }, {});\n    };\n    var componentDidMount = lifeCycleWrapperFactory('componentDidMount', function (target) {\n        target[PROXY_IS_MOUNTED] = true;\n        target[RENDERED_GENERATION] = get$1();\n        instancesCount++;\n    });\n    var componentDidUpdate = lifeCycleWrapperFactory('componentDidUpdate', renderOptions.componentDidUpdate);\n    var componentWillUnmount = lifeCycleWrapperFactory('componentWillUnmount', function (target) {\n        target[PROXY_IS_MOUNTED] = false;\n        instancesCount--;\n    });\n    function hotComponentRender() {\n        // repeating subrender call to keep RENDERED_GENERATION up to date\n        renderOptions.componentWillRender(this);\n        proxiedUpdate.call(this);\n        var result = void 0;\n        // We need to use hasOwnProperty here, as the cached result is a React node\n        // and can be null or some other falsy value.\n        if (has.call(this, CACHED_RESULT)) {\n            result = this[CACHED_RESULT];\n            delete this[CACHED_RESULT];\n        }\n        else if (isFunctionalComponent) {\n            result = CurrentComponent(this.props, this.context);\n        }\n        else {\n            var renderMethod = CurrentComponent.prototype.render || this.render;\n            /* eslint-disable no-use-before-define */\n            if (renderMethod === proxiedRender) {\n                throw new Error('React-Hot-Loader: you are trying to render Component without .render method');\n            }\n            /* eslint-enable */\n            result = renderMethod.apply(this, \n            // eslint-disable-next-line prefer-rest-params\n            arguments);\n        }\n        return renderOptions.componentDidRender.call(this, result);\n    }\n    function hotComponentUpdate() {\n        renderOptions.componentWillRender(this);\n        proxiedUpdate.call(this);\n    }\n    function proxiedRender() {\n        renderOptions.componentWillRender(this);\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n        }\n        return hotComponentRender.call.apply(hotComponentRender, [this].concat(args));\n    }\n    var defineProxyMethods = function defineProxyMethods(Proxy) {\n        var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        defineClassMembers(Proxy, _extends({}, fakeBasePrototype(Base), proxyConfig.pureRender ? {} : { render: proxiedRender }, {\n            hotComponentRender: hotComponentRender,\n            hotComponentUpdate: hotComponentUpdate,\n            componentDidMount: componentDidMount,\n            componentDidUpdate: componentDidUpdate,\n            componentWillUnmount: componentWillUnmount\n        }));\n    };\n    var _ProxyFacade = void 0;\n    var ProxyComponent = null;\n    var proxy = void 0;\n    if (!isFunctionalComponent) {\n        // Component\n        ProxyComponent = proxyClassCreator(InitialComponent, postConstructionAction);\n        defineProxyMethods(ProxyComponent, InitialComponent.prototype);\n        knownClassComponents.push(ProxyComponent);\n        _ProxyFacade = ProxyComponent;\n    }\n    else if (!proxyConfig.allowSFC) {\n        proxyConfig.pureRender = false;\n        // SFC Converted to component. Does not support returning precreated instances from render.\n        ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);\n        defineProxyMethods(ProxyComponent);\n        _ProxyFacade = ProxyComponent;\n    }\n    else {\n        // SFC\n        // This function only gets called for the initial mount. The actual\n        // rendered component instance will be the return value.\n        // eslint-disable-next-line func-names\n        _ProxyFacade = function ProxyFacade(props, context) {\n            /*\n               ! THIS IS NOT YOUR COMPONENT !\n              !  THIS IS REACT-HOT-LOADER  !\n               And you are probably looking for a function component of yours\n              It's hidden, but there is a way to fix this - just reconfigure your application a bit\n              see https://github.com/gaearon/react-hot-loader/issues/1311\n              */\n            var result = CurrentComponent(props, context);\n            // This is a Relay-style container constructor. We can't do the prototype-\n            // style wrapping for this as we do elsewhere, so just we just pass it\n            // through as-is.\n            if (isReactClassInstance(result)) {\n                ProxyComponent = null;\n                // Relay lazily sets statics like getDerivedStateFromProps on initial\n                // render in lazy construction, so we need to do the same here.\n                transferStaticProps(_ProxyFacade, savedDescriptors, null, CurrentComponent);\n                return result;\n            }\n            // simple SFC, could continue to be SFC\n            if (proxyConfig.pureSFC) {\n                if (!CurrentComponent.contextTypes) {\n                    if (!_ProxyFacade.isStatelessFunctionalProxy) {\n                        setSFPFlag(_ProxyFacade, true);\n                    }\n                    return renderOptions.componentDidRender(result);\n                }\n            }\n            setSFPFlag(_ProxyFacade, false);\n            proxyConfig.pureRender = false;\n            // Otherwise, it's a normal functional component. Build the real proxy\n            // and use it going forward.\n            ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);\n            defineProxyMethods(ProxyComponent);\n            var determinateResult = new ProxyComponent(props, context);\n            // Cache the initial render result so we don't call the component function\n            // a second time for the initial render.\n            determinateResult[CACHED_RESULT] = result;\n            return determinateResult;\n        };\n    }\n    function get$$1() {\n        return _ProxyFacade;\n    }\n    function getCurrent() {\n        return CurrentComponent;\n    }\n    safeDefineProperty(_ProxyFacade, UNWRAP_PROXY, {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: getCurrent\n    });\n    safeDefineProperty(_ProxyFacade, PROXY_KEY, {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: proxyKey\n    });\n    safeDefineProperty(_ProxyFacade, 'toString', {\n        configurable: true,\n        writable: false,\n        enumerable: false,\n        value: function toString() {\n            return String(CurrentComponent);\n        }\n    });\n    function update(NextComponent) {\n        if (typeof NextComponent !== 'function') {\n            throw new Error('Expected a constructor.');\n        }\n        if (NextComponent === CurrentComponent) {\n            return false;\n        }\n        // Prevent proxy cycles\n        var existingProxy = proxies.get(NextComponent);\n        if (existingProxy) {\n            return false;\n        }\n        isFunctionalComponent = !isReactClass(NextComponent);\n        proxies.set(NextComponent, proxy);\n        proxyGeneration++;\n        // Save the next constructor so we call it\n        var PreviousComponent = CurrentComponent;\n        CurrentComponent = NextComponent;\n        // Try to infer displayName\n        var displayName = getComponentDisplayName(CurrentComponent);\n        safeDefineProperty(_ProxyFacade, 'displayName', {\n            configurable: true,\n            writable: false,\n            enumerable: true,\n            value: displayName\n        });\n        if (ProxyComponent) {\n            safeDefineProperty(ProxyComponent, 'name', {\n                value: displayName\n            });\n        }\n        savedDescriptors = transferStaticProps(_ProxyFacade, savedDescriptors, PreviousComponent, NextComponent);\n        if (isFunctionalComponent || !ProxyComponent)\n            ;\n        else {\n            var classHotReplacement = function classHotReplacement() {\n                checkLifeCycleMethods(ProxyComponent, NextComponent);\n                if (proxyGeneration > 1) {\n                    getElementCloseHook(ProxyComponent);\n                    filteredPrototypeMethods(ProxyComponent.prototype).forEach(function (methodName) {\n                        if (!has.call(NextComponent.prototype, methodName)) {\n                            delete ProxyComponent.prototype[methodName];\n                        }\n                    });\n                }\n                Object.setPrototypeOf(ProxyComponent.prototype, NextComponent.prototype);\n                defineProxyMethods(ProxyComponent, NextComponent.prototype);\n                if (proxyGeneration > 1) {\n                    injectedMembers = mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers);\n                    getElementComparisonHook(ProxyComponent);\n                }\n            };\n            // Was constructed once\n            if (instancesCount > 0) {\n                classHotReplacement();\n            }\n            else {\n                classUpdatePostponed = classHotReplacement;\n            }\n        }\n        return true;\n    }\n    update(InitialComponent);\n    var dereference = function dereference() {\n        proxies.delete(InitialComponent);\n        proxies.delete(_ProxyFacade);\n        proxies.delete(CurrentComponent);\n    };\n    proxy = { get: get$$1, update: update, dereference: dereference, getCurrent: function getCurrent() {\n            return CurrentComponent;\n        } };\n    proxies.set(InitialComponent, proxy);\n    proxies.set(_ProxyFacade, proxy);\n    safeDefineProperty(proxy, UNWRAP_PROXY, {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: getCurrent\n    });\n    return proxy;\n}\n// this counter tracks `register` invocations.\n// works good, but code splitting is breaking it\nvar generation = 1;\n// these counters are aimed to mitigate the \"first render\"\nvar hotComparisonCounter = 0;\nvar hotComparisonRuns = 0;\nvar hotReplacementGeneration = 0;\nvar nullFunction = function nullFunction() {\n    return {};\n};\n// these callbacks would be called on component update\nvar onHotComparisonOpen = nullFunction;\nvar onHotComparisonElement = nullFunction;\nvar onHotComparisonClose = nullFunction;\n// inversion of control\nvar setComparisonHooks = function setComparisonHooks(open, element, close) {\n    onHotComparisonOpen = open;\n    onHotComparisonElement = element;\n    onHotComparisonClose = close;\n};\nvar getElementComparisonHook = function getElementComparisonHook(component) {\n    return onHotComparisonElement(component);\n};\nvar getElementCloseHook = function getElementCloseHook(component) {\n    return onHotComparisonClose(component);\n};\nvar hotComparisonOpen = function hotComparisonOpen() {\n    return hotComparisonCounter > 0 && hotComparisonRuns > 0 && hotReplacementGeneration > 0;\n};\nvar openGeneration = function openGeneration() {\n    return forEachKnownClass(onHotComparisonElement);\n};\nvar closeGeneration = function closeGeneration() {\n    return forEachKnownClass(onHotComparisonClose);\n};\nvar incrementHot = function incrementHot() {\n    if (!hotComparisonCounter) {\n        openGeneration();\n        onHotComparisonOpen();\n    }\n    hotComparisonCounter++;\n};\nvar decrementHot = function decrementHot() {\n    hotComparisonCounter--;\n    if (!hotComparisonCounter) {\n        closeGeneration();\n        hotComparisonRuns++;\n    }\n};\n// TODO: shall it be called from incrementHotGeneration?\nvar enterHotUpdate = function enterHotUpdate() {\n    Promise.resolve(incrementHot()).then(function () {\n        return setTimeout(decrementHot, 0);\n    });\n};\n// TODO: deprecate?\nvar increment = function increment() {\n    enterHotUpdate();\n    return generation++;\n};\nvar get$1 = function get() {\n    return generation;\n};\n// These counters tracks HMR generations, and probably should be used instead of the old one\nvar incrementHotGeneration = function incrementHotGeneration() {\n    return hotReplacementGeneration++;\n};\nvar getHotGeneration = function getHotGeneration() {\n    return hotReplacementGeneration;\n};\n// some `empty` names, React can autoset display name to...\nvar UNDEFINED_NAMES = {\n    Unknown: true,\n    Component: true\n};\nvar areNamesEqual = function areNamesEqual(a, b) {\n    return a === b || UNDEFINED_NAMES[a] && UNDEFINED_NAMES[b];\n};\nvar isFunctional = function isFunctional(fn) {\n    return typeof fn === 'function';\n};\nvar getTypeOf = function getTypeOf(type) {\n    if (isReactClass(type))\n        return 'ReactComponent';\n    if (isFunctional(type))\n        return 'StatelessFunctional';\n    return 'Fragment'; // ?\n};\nfunction clearStringFast(str) {\n    return str.length < 12 ? str : (' ' + str).slice(1);\n}\nvar haveTextSimilarity = function haveTextSimilarity(a, b) {\n    return (\n    // equal or slight changed\n    a === b || levenshtein.get(clearStringFast(a), clearStringFast(b)) < a.length * 0.2);\n};\nvar getBaseProto = function getBaseProto(source) {\n    return source.prototype.hotComponentRender ? Object.getPrototypeOf(source.prototype) : source.prototype;\n};\nvar equalClasses = function equalClasses(a, b) {\n    var prototypeA = getBaseProto(a);\n    var prototypeB = getBaseProto(b);\n    var hits = 0;\n    var misses = 0;\n    var comparisons = 0;\n    Object.getOwnPropertyNames(prototypeA).forEach(function (key) {\n        var descriptorA = Object.getOwnPropertyDescriptor(prototypeA, key);\n        var valueA = descriptorA && (descriptorA.value || descriptorA.get || descriptorA.set);\n        var descriptorB = Object.getOwnPropertyDescriptor(prototypeB, key);\n        var valueB = descriptorB && (descriptorB.value || descriptorB.get || descriptorB.set);\n        if (typeof valueA === 'function' && key !== 'constructor') {\n            comparisons++;\n            if (haveTextSimilarity(String(valueA), String(valueB))) {\n                hits++;\n            }\n            else {\n                misses++;\n                if (key === 'render') {\n                    misses++;\n                }\n            }\n        }\n    });\n    // allow to add or remove one function\n    return hits > 0 && misses <= 1 || comparisons === 0;\n};\nvar areSwappable = function areSwappable(a, b) {\n    // both are registered components and have the same name\n    if (getIdByType(b) && getIdByType(a) === getIdByType(b)) {\n        return true;\n    }\n    if (getTypeOf(a) !== getTypeOf(b)) {\n        return false;\n    }\n    if (isReactClass(a)) {\n        return areNamesEqual(getComponentDisplayName(a), getComponentDisplayName(b)) && equalClasses(a, b);\n    }\n    if (isFunctional(a)) {\n        var nameA = getComponentDisplayName(a);\n        if (!areNamesEqual(nameA, getComponentDisplayName(b))) {\n            return false;\n        }\n        return nameA !== 'Component' || haveTextSimilarity(String(a), String(b));\n    }\n    return false;\n};\nfunction merge() {\n    var acc = {};\n    for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n    }\n    for (var _iterator = sources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n        if (_isArray) {\n            if (_i >= _iterator.length)\n                break;\n            _ref = _iterator[_i++];\n        }\n        else {\n            _i = _iterator.next();\n            if (_i.done)\n                break;\n            _ref = _i.value;\n        }\n        var source = _ref;\n        if (source instanceof Array) {\n            if (!(acc instanceof Array)) {\n                acc = [];\n            }\n            acc = [].concat(acc, source);\n        }\n        else if (source instanceof Object) {\n            for (var _iterator2 = Object.keys(source), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n                var _babelHelpers$extends;\n                var _ref2;\n                if (_isArray2) {\n                    if (_i2 >= _iterator2.length)\n                        break;\n                    _ref2 = _iterator2[_i2++];\n                }\n                else {\n                    _i2 = _iterator2.next();\n                    if (_i2.done)\n                        break;\n                    _ref2 = _i2.value;\n                }\n                var key = _ref2;\n                var value = source[key];\n                if (value instanceof Object && key in acc) {\n                    value = merge(acc[key], value);\n                }\n                acc = _extends({}, acc, (_babelHelpers$extends = {}, _babelHelpers$extends[key] = value, _babelHelpers$extends));\n            }\n        }\n    }\n    return acc;\n}\nvar signatures = void 0;\nvar proxiesByID = void 0;\nvar blackListedProxies = void 0;\nvar registeredComponents = void 0;\nvar idsByType = void 0;\nvar elementCount = 0;\nvar renderOptions = {};\nvar componentOptions = void 0;\nvar generateTypeId = function generateTypeId() {\n    return 'auto-' + elementCount++;\n};\nvar getIdByType = function getIdByType(type) {\n    return idsByType.get(type);\n};\nvar isProxyType = function isProxyType(type) {\n    return type[PROXY_KEY];\n};\nvar getProxyById = function getProxyById(id) {\n    return proxiesByID[id];\n};\nvar getProxyByType = function getProxyByType(type) {\n    return getProxyById(getIdByType(type));\n};\nvar registerComponent = function registerComponent(type) {\n    return registeredComponents.set(type, 1);\n};\nvar isRegisteredComponent = function isRegisteredComponent(type) {\n    return registeredComponents.has(type);\n};\nvar setStandInOptions = function setStandInOptions(options) {\n    renderOptions = options;\n};\nvar updateFunctionProxyById = function updateFunctionProxyById(id, type, updater) {\n    // Remember the ID.\n    idsByType.set(type, id);\n    var proxy = proxiesByID[id];\n    if (!proxy) {\n        proxiesByID[id] = type;\n    }\n    updater(proxiesByID[id], type);\n    // proxiesByID[id] = type; // keep the first ref\n    return proxiesByID[id];\n};\nvar updateProxyById = function updateProxyById(id, type) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!id) {\n        return null;\n    }\n    // Remember the ID.\n    idsByType.set(type, id);\n    if (!proxiesByID[id]) {\n        proxiesByID[id] = createClassProxy(type, id, merge({}, renderOptions, { proxy: componentOptions.get(type) || {} }, options));\n    }\n    else if (proxiesByID[id].update(type)) {\n        // proxy could be registered again only in case of HMR\n        incrementHotGeneration();\n    }\n    return proxiesByID[id];\n};\nvar createProxyForType = function createProxyForType(type, options) {\n    return getProxyByType(type) || updateProxyById(generateTypeId(), type, options);\n};\nvar isColdType = function isColdType(type) {\n    return blackListedProxies.has(type);\n};\nvar isTypeBlacklisted = function isTypeBlacklisted(type) {\n    return isColdType(type) || isCompositeComponent(type) && (configuration.ignoreSFC && !isReactClass(type) || configuration.ignoreComponents && isReactClass(type));\n};\nvar blacklistByType = function blacklistByType(type) {\n    return blackListedProxies.set(type, true);\n};\nvar setComponentOptions = function setComponentOptions(component, options) {\n    return componentOptions.set(component, options);\n};\nvar addSignature = function addSignature(type, signature) {\n    return signatures.set(type, signature);\n};\nvar getSignature = function getSignature(type) {\n    return signatures.get(type);\n};\nvar resetProxies = function resetProxies() {\n    proxiesByID = {};\n    idsByType = new WeakMap();\n    blackListedProxies = new WeakMap();\n    registeredComponents = new WeakMap();\n    componentOptions = new WeakMap();\n    signatures = new WeakMap();\n    resetClassProxies();\n};\nresetProxies();\nvar tune = {\n    allowSFC: false\n};\nvar preactAdapter = function preactAdapter(instance, resolveType) {\n    var oldHandler = instance.options.vnode;\n    setConfiguration(tune);\n    instance.options.vnode = function (vnode) {\n        if (vnode.type) {\n            vnode.type = resolveType(vnode.type);\n        }\n        else if (vnode.nodeName) {\n            vnode.nodeName = resolveType(vnode.nodeName);\n        }\n        if (oldHandler) {\n            oldHandler(vnode);\n        }\n    };\n};\n/* global document */\nvar lastError = [];\nvar overlayStyle = {\n    position: 'fixed',\n    left: 0,\n    top: 0,\n    right: 0,\n    backgroundColor: 'rgba(255,200,200,0.9)',\n    color: '#000',\n    fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif',\n    fontSize: '12px',\n    margin: 0,\n    padding: '16px',\n    maxHeight: '50%',\n    overflow: 'auto',\n    zIndex: 10000\n};\nvar inlineErrorStyle = {\n    backgroundColor: '#FEE'\n};\nvar liCounter = {\n    position: 'absolute',\n    left: '10px'\n};\nvar listStyle = {};\nvar EmptyErrorPlaceholder = function EmptyErrorPlaceholder(_ref) {\n    var component = _ref.component;\n    return React__default.createElement('span', { style: inlineErrorStyle, role: 'img', 'aria-label': 'Rect-Hot-Loader Error' }, '\\u269B\\uFE0F\\uD83D\\uDD25\\uD83E\\uDD15 (', component ? getComponentDisplayName(component.constructor || component) : 'Unknown location', ')', component && component.retryHotLoaderError && React__default.createElement('button', { onClick: function onClick() {\n            return component.retryHotLoaderError();\n        }, title: 'Retry' }, '\\u27F3'));\n};\nvar errorHeader = function errorHeader(component, componentStack) {\n    if (component || componentStack) {\n        return React__default.createElement('span', null, '(', component ? getComponentDisplayName(component.constructor || component) : 'Unknown location', component && ', ', componentStack && componentStack.split('\\n').filter(Boolean)[0], ')');\n    }\n    return null;\n};\nvar mapError = function mapError(_ref2) {\n    var error = _ref2.error, errorInfo = _ref2.errorInfo, component = _ref2.component;\n    if (!error) {\n        error = { message: 'undefined error' };\n    }\n    return React__default.createElement(React__default.Fragment, null, React__default.createElement('p', { style: { color: 'red' } }, errorHeader(component, errorInfo && errorInfo.componentStack), ' ', error.toString ? error.toString() : error && error.message || 'undefined error'), errorInfo && errorInfo.componentStack ? React__default.createElement('div', null, React__default.createElement('div', null, 'Stack trace:'), React__default.createElement('ul', { style: { color: 'red', marginTop: '10px' } }, error.stack.split('\\n').slice(1, 2).map(function (line, i) {\n        return React__default.createElement('li', { key: String(i) }, line);\n    }), React__default.createElement('hr', null), errorInfo.componentStack.split('\\n').filter(Boolean).map(function (line, i) {\n        return React__default.createElement('li', { key: String(i) }, line);\n    }))) : error.stack && React__default.createElement('div', null, React__default.createElement('div', null, 'Stack trace:'), React__default.createElement('ul', { style: { color: 'red', marginTop: '10px' } }, error.stack.split('\\n').map(function (line, i) {\n        return React__default.createElement('li', { key: String(i) }, line);\n    }))));\n};\nvar ErrorOverlay = function (_React$Component) {\n    inherits(ErrorOverlay, _React$Component);\n    function ErrorOverlay() {\n        var _temp, _this, _ret;\n        classCallCheck(this, ErrorOverlay);\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n            visible: true\n        }, _this.toggle = function () {\n            return _this.setState({ visible: !_this.state.visible });\n        }, _this.retry = function () {\n            return _this.setState(function () {\n                var errors = _this.props.errors;\n                enterHotUpdate();\n                clearExceptions();\n                errors.map(function (_ref3) {\n                    var component = _ref3.component;\n                    return component;\n                }).filter(Boolean).filter(function (_ref4) {\n                    var retryHotLoaderError = _ref4.retryHotLoaderError;\n                    return !!retryHotLoaderError;\n                }).forEach(function (component) {\n                    return component.retryHotLoaderError();\n                });\n                return {};\n            });\n        }, _temp), possibleConstructorReturn(_this, _ret);\n    }\n    ErrorOverlay.prototype.render = function render() {\n        var errors = this.props.errors;\n        if (!errors.length) {\n            return null;\n        }\n        var visible = this.state.visible;\n        return React__default.createElement('div', { style: overlayStyle }, React__default.createElement('h2', { style: { margin: 0 } }, '\\u269B\\uFE0F\\uD83D\\uDD25\\uD83D\\uDE2D: hot update was not successful ', React__default.createElement('button', { onClick: this.toggle }, visible ? 'collapse' : 'expand'), React__default.createElement('button', { onClick: this.retry }, 'Retry')), visible && React__default.createElement('ul', { style: listStyle }, errors.map(function (err, i) {\n            return React__default.createElement('li', { key: i }, React__default.createElement('span', { style: liCounter }, '(', i + 1, '/', errors.length, ')'), mapError(err));\n        })));\n    };\n    return ErrorOverlay;\n}(React__default.Component);\nvar initErrorOverlay = function initErrorOverlay() {\n    if (typeof document === 'undefined' || !document.body) {\n        return;\n    }\n    var div = document.querySelector('.react-hot-loader-error-overlay');\n    if (!div) {\n        div = document.createElement('div');\n        div.className = 'react-hot-loader-error-overlay';\n        document.body.appendChild(div);\n    }\n    if (lastError.length) {\n        var Overlay = configuration.ErrorOverlay || ErrorOverlay;\n        ReactDOM.render(React__default.createElement(Overlay, { errors: lastError }), div);\n    }\n    else {\n        div.parentNode.removeChild(div);\n    }\n};\nfunction clearExceptions() {\n    if (lastError.length) {\n        lastError = [];\n        initErrorOverlay();\n    }\n}\nfunction logException(error, errorInfo, component) {\n    // do not suppress error\n    /* eslint-disable no-console */\n    console.error(error);\n    /* eslint-enable */\n    lastError.push({ error: error, errorInfo: errorInfo, component: component });\n    initErrorOverlay();\n}\n/* eslint-disable no-underscore-dangle */\nvar hotRenderWithHooks = ReactDOM.hotRenderWithHooks || function (fiber, render) {\n    return render();\n};\nfunction pushStack(stack, node) {\n    stack.type = node.type;\n    stack.elementType = node.elementType || node.type;\n    stack.children = [];\n    stack.instance = typeof node.type === 'function' ? node.stateNode : stack;\n    stack.fiber = node;\n    if (!stack.instance) {\n        stack.instance = {\n            SFC_fake: stack.type,\n            props: {},\n            render: function render() {\n                return hotRenderWithHooks(node, function () {\n                    return stack.type(stack.instance.props);\n                });\n            }\n        };\n    }\n}\nfunction hydrateFiberStack(node, stack) {\n    pushStack(stack, node);\n    if (node.child) {\n        var child = node.child;\n        do {\n            var childStack = {};\n            hydrateFiberStack(child, childStack);\n            stack.children.push(childStack);\n            child = child.sibling;\n        } while (child);\n    }\n}\n/* eslint-disable no-underscore-dangle */\nfunction pushState(stack, type, instance) {\n    stack.type = type;\n    stack.elementType = type;\n    stack.children = [];\n    stack.instance = instance || stack;\n    if (typeof type === 'function' && type.isStatelessFunctionalProxy) {\n        // In React 15 SFC is wrapped by component. We have to detect our proxies and change the way it works\n        stack.instance = {\n            SFC_fake: type,\n            props: {},\n            render: function render() {\n                return type(stack.instance.props);\n            }\n        };\n    }\n}\nfunction hydrateLegacyStack(node, stack) {\n    if (node._currentElement) {\n        pushState(stack, node._currentElement.type, node._instance || stack);\n    }\n    if (node._renderedComponent) {\n        var childStack = {};\n        hydrateLegacyStack(node._renderedComponent, childStack);\n        stack.children.push(childStack);\n    }\n    else if (node._renderedChildren) {\n        Object.keys(node._renderedChildren).forEach(function (key) {\n            var childStack = {};\n            hydrateLegacyStack(node._renderedChildren[key], childStack);\n            stack.children.push(childStack);\n        });\n    }\n}\nvar shouldNotPatchComponent = function shouldNotPatchComponent(type) {\n    return isTypeBlacklisted(type);\n};\nfunction resolveUtility(type) {\n    // all \"utility\" types are resolved to their __initial__ shapes\n    // that enables to never change reference to them, and gives the ability to maintain React Tree on HMR\n    // all operations could be skipped with react-hot-dom enabled\n    if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n        if (configuration.integratedComparator) {\n            return type;\n        }\n        var element = { type: type };\n        if (isLazyType(element) || isMemoType(element) || isForwardType(element) || isContextType(element)) {\n            return getProxyByType(type) || type;\n        }\n    }\n    return undefined;\n}\nfunction resolveComponent(type) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var existingProxy = getProxyByType(type);\n    // cold API\n    if (shouldNotPatchComponent(type)) {\n        return existingProxy ? existingProxy.getCurrent() : type;\n    }\n    if (!existingProxy && configuration.onComponentCreate) {\n        configuration.onComponentCreate(type, getComponentDisplayName(type));\n        if (shouldNotPatchComponent(type)) {\n            return type;\n        }\n    }\n    var proxy = internalConfiguration.disableProxyCreation ? existingProxy : createProxyForType(type, options);\n    return proxy ? proxy.get() : undefined;\n}\nfunction resolveProxy(type) {\n    if (isProxyType(type)) {\n        return type;\n    }\n    return undefined;\n}\nfunction resolveNotComponent(type) {\n    if (!isCompositeComponent(type)) {\n        return type;\n    }\n    return undefined;\n}\nvar getLatestTypeVersion = function getLatestTypeVersion(type) {\n    var existingProxy = getProxyByType(type);\n    return existingProxy && existingProxy.getCurrent && existingProxy.getCurrent();\n};\nvar resolveSimpleType = function resolveSimpleType(type) {\n    if (!type) {\n        return type;\n    }\n    var simpleResult = resolveProxy(type) || resolveUtility(type) || resolveNotComponent(type);\n    if (simpleResult) {\n        return simpleResult;\n    }\n    var lastType = getLatestTypeVersion(type);\n    // only lazy loaded components any now failing into this branch\n    // if (lastType && lastType !== type) {\n    //   console.warn('RHL: used type', type, 'is obsolete. Something is wrong with HMR.');\n    // }\n    return lastType || type;\n};\nvar resolveType = function resolveType(type) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!type) {\n        return type;\n    }\n    return resolveProxy(type) || resolveUtility(type) || resolveNotComponent(type) || resolveComponent(type, options) || type;\n};\n/* eslint-disable no-underscore-dangle */\nfunction getReactStack(instance) {\n    var rootNode = getInternalInstance(instance);\n    var stack = {};\n    if (rootNode) {\n        // React stack\n        var isFiber = typeof rootNode.tag === 'number';\n        if (isFiber) {\n            hydrateFiberStack(rootNode, stack);\n        }\n        else {\n            hydrateLegacyStack(rootNode, stack);\n        }\n    }\n    return stack;\n}\nvar markUpdate = function markUpdate(_ref) {\n    var fiber = _ref.fiber;\n    // do not update what we should not\n    if (!fiber || typeof fiber.type === 'string') {\n        return;\n    }\n    var mostResentType = resolveType(fiber.type) || fiber.type;\n    fiber.type = mostResentType;\n    // do not change fiber.elementType to keep old information for the hot-update\n    fiber.expirationTime = 1;\n    if (fiber.alternate) {\n        fiber.alternate.expirationTime = 1;\n        fiber.alternate.type = fiber.type;\n    }\n    if (fiber.memoizedProps && _typeof(fiber.memoizedProps) === 'object') {\n        fiber.memoizedProps = _extends({\n            cacheBusterProp: true\n        }, fiber.memoizedProps);\n    }\n    if (fiber.stateNode)\n        ;\n};\nvar cleanupReact = function cleanupReact() {\n    if (ReactDOM.hotCleanup) {\n        ReactDOM.hotCleanup();\n    }\n};\nvar deepMarkUpdate = function deepMarkUpdate(stack) {\n    markUpdate(stack);\n    if (stack.children) {\n        stack.children.forEach(deepMarkUpdate);\n    }\n};\nvar renderStack = [];\nvar stackReport = function stackReport() {\n    var rev = renderStack.slice().reverse();\n    logger.warn('in', rev[0].name, rev);\n};\nvar emptyMap = new Map();\nvar stackContext = function stackContext() {\n    return (renderStack[renderStack.length - 1] || {}).context || emptyMap;\n};\nvar shouldUseRenderMethod = function shouldUseRenderMethod(fn) {\n    return fn && (isReactClassInstance(fn) || fn.SFC_fake);\n};\nvar getElementType$1 = function getElementType$$1(child) {\n    return child.type[UNWRAP_PROXY] ? child.type[UNWRAP_PROXY]() : child.type;\n};\nvar filterNullArray = function filterNullArray(a) {\n    if (!a)\n        return [];\n    return a.filter(function (x) {\n        return !!x;\n    });\n};\nvar unflatten = function unflatten(a) {\n    return a.reduce(function (acc, a) {\n        if (Array.isArray(a)) {\n            acc.push.apply(acc, unflatten(a));\n        }\n        else {\n            acc.push(a);\n        }\n        return acc;\n    }, []);\n};\nvar isArray = function isArray(fn) {\n    return Array.isArray(fn);\n};\nvar asArray = function asArray(a) {\n    return isArray(a) ? a : [a];\n};\nvar render = function render(component, stack) {\n    if (!component) {\n        return [];\n    }\n    if (component.hotComponentUpdate) {\n        component.hotComponentUpdate();\n    }\n    if (shouldUseRenderMethod(component)) {\n        // not calling real render method to prevent call recursion.\n        // stateless components does not have hotComponentRender\n        return component.hotComponentRender ? component.hotComponentRender() : component.render();\n    }\n    if (isForwardType(component)) {\n        // render forward type in a sandbox\n        return hotRenderWithHooks(stack.fiber, function () {\n            return component.type.render(component.props, null);\n        });\n    }\n    if (isArray(component)) {\n        return component.map(render);\n    }\n    if (component.children) {\n        return component.children;\n    }\n    return [];\n};\nvar NO_CHILDREN = { children: [] };\nvar mapChildren = function mapChildren(children, instances) {\n    return {\n        children: children.filter(function (c) {\n            return c;\n        }).map(function (child, index) {\n            if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object' || child.isMerged) {\n                return child;\n            }\n            var instanceLine = instances[index] || {};\n            var oldChildren = asArray(instanceLine.children || []);\n            if (Array.isArray(child)) {\n                return _extends({\n                    type: null\n                }, mapChildren(child, oldChildren));\n            }\n            var newChildren = asArray(child.props && child.props.children || child.children || []);\n            var nextChildren = child.type !== 'function' && oldChildren.length && mapChildren(newChildren, oldChildren);\n            return _extends({\n                nextProps: child.props,\n                isMerged: true\n            }, instanceLine, nextChildren || {}, {\n                type: child.type\n            });\n        })\n    };\n};\nvar mergeInject = function mergeInject(a, b, instance) {\n    if (a && !Array.isArray(a)) {\n        return mergeInject([a], b);\n    }\n    if (b && !Array.isArray(b)) {\n        return mergeInject(a, [b]);\n    }\n    if (!a || !b) {\n        return NO_CHILDREN;\n    }\n    if (a.length === b.length) {\n        return mapChildren(a, b);\n    }\n    // in some cases (no confidence here) B could contain A except null children\n    // in some cases - could not.\n    // this depends on React version and the way you build component.\n    var nonNullA = filterNullArray(a);\n    if (nonNullA.length === b.length) {\n        return mapChildren(nonNullA, b);\n    }\n    var flatA = unflatten(nonNullA);\n    var flatB = unflatten(b);\n    if (flatA.length === flatB.length) {\n        return mapChildren(flatA, flatB);\n    }\n    if (flatB.length === 0 && flatA.length === 1 && _typeof(flatA[0]) !== 'object')\n        ;\n    else if (!configuration.IS_REACT_MERGE_ENABLED) {\n        logger.warn('React-hot-loader: unable to merge ', a, 'and children of ', instance);\n        stackReport();\n    }\n    return NO_CHILDREN;\n};\nvar transformFlowNode = function transformFlowNode(flow) {\n    return flow.reduce(function (acc, node) {\n        if (node && isFragmentNode(node)) {\n            if (node.props && node.props.children) {\n                return [].concat(acc, filterNullArray(asArray(node.props.children)));\n            }\n            if (node.children) {\n                return [].concat(acc, filterNullArray(asArray(node.children)));\n            }\n        }\n        return [].concat(acc, [node]);\n    }, []);\n};\nvar scheduledUpdates = [];\nvar scheduledUpdate = 0;\nvar flushScheduledUpdates = function flushScheduledUpdates() {\n    var instances = scheduledUpdates;\n    scheduledUpdates = [];\n    scheduledUpdate = 0;\n    instances.forEach(function (instance) {\n        return instance[PROXY_IS_MOUNTED] && updateInstance(instance);\n    });\n};\nvar unscheduleUpdate = function unscheduleUpdate(instance) {\n    scheduledUpdates = scheduledUpdates.filter(function (inst) {\n        return inst !== instance;\n    });\n};\nvar scheduleInstanceUpdate = function scheduleInstanceUpdate(instance) {\n    scheduledUpdates.push(instance);\n    if (!scheduledUpdate) {\n        scheduledUpdate = setTimeout(flushScheduledUpdates, 4);\n    }\n};\nvar hotReplacementRender = function hotReplacementRender(instance, stack) {\n    if (isReactClassInstance(instance)) {\n        var type = getElementType$1(stack);\n        renderStack.push({\n            name: getComponentDisplayName(type),\n            type: type,\n            props: stack.instance.props,\n            context: stackContext()\n        });\n    }\n    try {\n        var flow = transformFlowNode(filterNullArray(asArray(render(instance, stack))));\n        var children = stack.children;\n        flow.forEach(function (child, index) {\n            var childType = child.type;\n            var stackChild = children[index];\n            var next = function next(instance) {\n                // copy over props as long new component may be hidden inside them\n                // child does not have all props, as long some of them can be calculated on componentMount.\n                var realProps = instance.props;\n                var nextProps = _extends({}, realProps, child.nextProps || {}, child.props || {});\n                if (isReactClassInstance(instance) && instance.componentWillUpdate) {\n                    // Force-refresh component (bypass redux renderedComponent)\n                    instance.componentWillUpdate(_extends({}, realProps), instance.state);\n                }\n                instance.props = nextProps;\n                hotReplacementRender(instance, stackChild);\n                instance.props = realProps;\n            };\n            // text node\n            if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object' || !stackChild || !stackChild.instance) {\n                if (stackChild && stackChild.children && stackChild.children.length) {\n                    logger.error('React-hot-loader: reconciliation failed', 'could not dive into [', child, '] while some elements are still present in the tree.');\n                    stackReport();\n                }\n                return;\n            }\n            // comparing rendered type to fiber.ElementType\n            if ((typeof childType === 'undefined' ? 'undefined' : _typeof(childType)) !== _typeof(stackChild.elementType)) {\n                // Portals could generate undefined !== null\n                if (childType && stackChild.type) {\n                    logger.warn('React-hot-loader: got ', childType, 'instead of', stackChild.type);\n                    stackReport();\n                }\n                return;\n            }\n            if (isMemoType(child) || isLazyType(child)) {\n                // force update memo children\n                if (stackChild.children && stackChild.children[0]) {\n                    scheduleInstanceUpdate(stackChild.children[0].instance);\n                }\n                childType = childType.type || childType;\n            }\n            if (isForwardType(child)) {\n                next(stackChild.instance);\n            }\n            else if (isContextConsumer(child)) {\n                try {\n                    var contextValue = stackContext().get(getContextProvider(childType));\n                    next({\n                        children: (child.props ? child.props.children : child.children[0])(contextValue !== undefined ? contextValue : childType[CONTEXT_CURRENT_VALUE])\n                    });\n                }\n                catch (e) {\n                    // do nothing, yet\n                }\n            }\n            else if (typeof childType !== 'function') {\n                // React\n                var childName = childType ? getComponentDisplayName(childType) : 'empty';\n                var extraContext = stackContext();\n                if (isContextProvider(child)) {\n                    extraContext = new Map(extraContext);\n                    extraContext.set(getContextProvider(childType), _extends({}, child.nextProps || {}, child.props || {}).value);\n                    childName = 'ContextProvider';\n                }\n                renderStack.push({\n                    name: childName,\n                    type: childType,\n                    props: stack.instance.props,\n                    context: extraContext\n                });\n                next(\n                // move types from render to the instances of hydrated tree\n                mergeInject(transformFlowNode(asArray(child.props ? child.props.children : child.children)), stackChild.instance.children, stackChild.instance));\n                renderStack.pop();\n            }\n            else {\n                if (childType === stackChild.type) {\n                    next(stackChild.instance);\n                }\n                else {\n                    // unwrap proxy\n                    var _childType = getElementType$1(child);\n                    if (isMemoType(child)) {\n                        _childType = _childType.type || _childType;\n                    }\n                    if (!stackChild.type[PROXY_KEY]) {\n                        if (!configuration.IS_REACT_MERGE_ENABLED) {\n                            if (isTypeBlacklisted(stackChild.type)) {\n                                logger.warn('React-hot-loader: cold element got updated ', stackChild.type);\n                            }\n                        }\n                    }\n                    if (isRegisteredComponent(_childType) || isRegisteredComponent(stackChild.type)) {\n                        // one of elements are registered via babel plugin, and should not be handled by hot swap\n                        if (resolveType(_childType) === resolveType(stackChild.type)) {\n                            next(stackChild.instance);\n                        }\n                    }\n                    else if (areSwappable(_childType, stackChild.type)) {\n                        // they are both registered, or have equal code/displayname/signature\n                        // update proxy using internal PROXY_KEY\n                        updateProxyById(stackChild.type[PROXY_KEY] || getIdByType(stackChild.type), _childType);\n                        next(stackChild.instance);\n                    }\n                    else {\n                        logger.warn('React-hot-loader: a ' + getComponentDisplayName(_childType) + ' was found where a ' + getComponentDisplayName(stackChild) + ' was expected.\\n          ' + _childType);\n                        stackReport();\n                    }\n                }\n                scheduleInstanceUpdate(stackChild.instance);\n            }\n        });\n    }\n    catch (e) {\n        if (e.then)\n            ;\n        else {\n            logger.warn('React-hot-loader: run time error during reconciliation', e);\n        }\n    }\n    if (isReactClassInstance(instance)) {\n        renderStack.pop();\n    }\n};\nvar hotReplacementRender$1 = (function (instance, stack) {\n    if (configuration.disableHotRenderer) {\n        return;\n    }\n    try {\n        // disable reconciler to prevent upcoming components from proxying.\n        internalConfiguration.disableProxyCreation = true;\n        renderStack = [];\n        hotReplacementRender(instance, stack);\n    }\n    catch (e) {\n        logger.warn('React-hot-loader: reconcilation failed due to error', e);\n    }\n    finally {\n        internalConfiguration.disableProxyCreation = false;\n    }\n});\nvar reconcileHotReplacement = function reconcileHotReplacement(ReactInstance) {\n    var stack = getReactStack(ReactInstance);\n    hotReplacementRender$1(ReactInstance, stack);\n    cleanupReact();\n    deepMarkUpdate(stack);\n};\nvar renderReconciler = function renderReconciler(target, force) {\n    // we are not inside parent reconcilation\n    var currentGeneration = get$1();\n    var componentGeneration = target[RENDERED_GENERATION];\n    target[RENDERED_GENERATION] = currentGeneration;\n    if (!internalConfiguration.disableProxyCreation) {\n        if ((componentGeneration || force) && componentGeneration !== currentGeneration) {\n            enterHotUpdate();\n            reconcileHotReplacement(target);\n            return true;\n        }\n    }\n    return false;\n};\nfunction asyncReconciledRender(target) {\n    renderReconciler(target, false);\n}\nfunction proxyWrapper(element) {\n    // post wrap on post render\n    if (!internalConfiguration.disableProxyCreation) {\n        unscheduleUpdate(this);\n    }\n    if (!element) {\n        return element;\n    }\n    if (Array.isArray(element)) {\n        return element.map(proxyWrapper);\n    }\n    if (typeof element.type === 'function') {\n        var proxy = getProxyByType(element.type);\n        if (proxy) {\n            return _extends({}, element, {\n                type: proxy.get()\n            });\n        }\n    }\n    return element;\n}\nvar ERROR_STATE = 'react_hot_loader_catched_error';\nvar ERROR_STATE_PROTO = 'react_hot_loader_catched_error-prototype';\nvar OLD_RENDER = 'react_hot_loader_original_render';\nfunction componentDidCatch(error, errorInfo) {\n    this[ERROR_STATE] = {\n        location: 'boundary',\n        error: error,\n        errorInfo: errorInfo,\n        generation: get$1()\n    };\n    Object.getPrototypeOf(this)[ERROR_STATE_PROTO] = this[ERROR_STATE];\n    if (!configuration.errorReporter) {\n        logException(error, errorInfo, this);\n    }\n    this.forceUpdate();\n}\nfunction componentRender() {\n    var _ref = this[ERROR_STATE] || {}, error = _ref.error, errorInfo = _ref.errorInfo, generation = _ref.generation;\n    if (error && generation === get$1()) {\n        return React__default.createElement(configuration.errorReporter || EmptyErrorPlaceholder, {\n            error: error,\n            errorInfo: errorInfo,\n            component: this\n        });\n    }\n    if (this.hotComponentUpdate) {\n        this.hotComponentUpdate();\n    }\n    try {\n        var _OLD_RENDER$render;\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        return (_OLD_RENDER$render = this[OLD_RENDER].render).call.apply(_OLD_RENDER$render, [this].concat(args));\n    }\n    catch (renderError) {\n        this[ERROR_STATE] = {\n            location: 'render',\n            error: renderError,\n            generation: get$1()\n        };\n        if (!configuration.errorReporter) {\n            logException(renderError, undefined, this);\n        }\n        return componentRender.call(this);\n    }\n}\nfunction retryHotLoaderError() {\n    delete this[ERROR_STATE];\n    this.forceUpdate();\n}\nsetComparisonHooks(function () {\n    return {};\n}, function (component) {\n    if (!hotComparisonOpen()) {\n        return;\n    }\n    var prototype = component.prototype;\n    if (!prototype[OLD_RENDER]) {\n        var renderDescriptior = Object.getOwnPropertyDescriptor(prototype, 'render');\n        prototype[OLD_RENDER] = {\n            descriptor: renderDescriptior ? renderDescriptior.value : undefined,\n            render: prototype.render\n        };\n        prototype.componentDidCatch = componentDidCatch;\n        prototype.retryHotLoaderError = retryHotLoaderError;\n        prototype.render = componentRender;\n    }\n    delete prototype[ERROR_STATE];\n}, function (_ref2) {\n    var prototype = _ref2.prototype;\n    if (prototype[OLD_RENDER]) {\n        var _ref3 = prototype[ERROR_STATE_PROTO] || {}, generation = _ref3.generation;\n        if (generation === get$1())\n            ;\n        else {\n            delete prototype.componentDidCatch;\n            delete prototype.retryHotLoaderError;\n            // undo only what we did\n            if (prototype.render === componentRender) {\n                if (!prototype[OLD_RENDER].descriptor) {\n                    delete prototype.render;\n                }\n                else {\n                    prototype.render = prototype[OLD_RENDER].descriptor;\n                }\n            }\n            else {\n                console.error('React-Hot-Loader: something unexpectedly mutated Component', prototype);\n            }\n            delete prototype[ERROR_STATE_PROTO];\n            delete prototype[OLD_RENDER];\n        }\n    }\n});\nsetStandInOptions({\n    componentWillRender: asyncReconciledRender,\n    componentDidRender: proxyWrapper,\n    componentDidUpdate: function componentDidUpdate(component) {\n        component[RENDERED_GENERATION] = get$1();\n        flushScheduledUpdates();\n    }\n});\nvar AppContainer = function (_React$Component) {\n    inherits(AppContainer, _React$Component);\n    AppContainer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n        if (prevState.generation !== get$1()) {\n            // Hot reload is happening.\n            return {\n                error: null,\n                generation: get$1()\n            };\n        }\n        return null;\n    };\n    function AppContainer(props) {\n        classCallCheck(this, AppContainer);\n        var _this = possibleConstructorReturn(this, _React$Component.call(this, props));\n        if (configuration.showReactDomPatchNotification) {\n            configuration.showReactDomPatchNotification = false;\n            console.warn('React-Hot-Loader: react-🔥-dom patch is not detected. React 16.6+ features may not work.');\n        }\n        _this.state = {\n            error: null,\n            errorInfo: null,\n            // eslint-disable-next-line react/no-unused-state\n            generation: 0\n        };\n        return _this;\n    }\n    AppContainer.prototype.shouldComponentUpdate = function shouldComponentUpdate(prevProps, prevState) {\n        // Don't update the component if the state had an error and still has one.\n        // This allows to break an infinite loop of error -> render -> error -> render\n        // https://github.com/gaearon/react-hot-loader/issues/696\n        if (prevState.error && this.state.error) {\n            return false;\n        }\n        return true;\n    };\n    AppContainer.prototype.componentDidCatch = function componentDidCatch(error, errorInfo) {\n        logger.error(error);\n        if (!hotComparisonOpen()) {\n            // do not log error outside of HMR cycle\n            // trigger update to kick error\n            this.setState({});\n            throw error;\n        }\n        var _props$errorReporter = this.props.errorReporter, errorReporter = _props$errorReporter === undefined ? configuration.errorReporter : _props$errorReporter;\n        if (!errorReporter) {\n            logException(error, errorInfo, this);\n        }\n        this.setState({\n            error: error,\n            errorInfo: errorInfo\n        });\n    };\n    AppContainer.prototype.retryHotLoaderError = function retryHotLoaderError$$1() {\n        var _this2 = this;\n        this.setState({ error: null }, function () {\n            retryHotLoaderError.call(_this2);\n        });\n    };\n    AppContainer.prototype.render = function render() {\n        var _state = this.state, error = _state.error, errorInfo = _state.errorInfo;\n        var _props$errorReporter2 = this.props.errorReporter, ErrorReporter = _props$errorReporter2 === undefined ? configuration.errorReporter || EmptyErrorPlaceholder : _props$errorReporter2;\n        if (error && this.props.errorBoundary) {\n            return React__default.createElement(ErrorReporter, { error: error, errorInfo: errorInfo, component: this });\n        }\n        if (this.hotComponentUpdate) {\n            this.hotComponentUpdate();\n        }\n        else {\n            throw new Error('React-Hot-Loader: AppContainer should be patched');\n        }\n        return React__default.Children.only(this.props.children);\n    };\n    return AppContainer;\n}(React__default.Component);\nAppContainer.reactHotLoadable = false;\nAppContainer.propTypes = {\n    children: function children(props) {\n        if (React__default.Children.count(props.children) !== 1) {\n            return new Error('Invalid prop \"children\" supplied to AppContainer. ' + 'Expected a single React element with your app’s root component, e.g. <App />.');\n        }\n        return undefined;\n    },\n    errorReporter: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n    errorBoundary: PropTypes.bool\n};\nAppContainer.defaultProps = {\n    errorBoundary: true\n};\n//  trying first react-lifecycles-compat.polyfill, then trying react-lifecycles-compat, which could be .default\nvar realPolyfill = defaultPolyfill.polyfill || defaultPolyfill__default;\nrealPolyfill(AppContainer);\n/* eslint-disable no-underscore-dangle */\nvar lazyConstructor = '_ctor';\nvar getLazyConstructor = function getLazyConstructor(target) {\n    // React 16\n    if (target[lazyConstructor]) {\n        return target[lazyConstructor];\n    }\n    // React 17\n    if (target._payload) {\n        return target._payload._result;\n    }\n    return null;\n};\nvar setLazyConstructor = function setLazyConstructor(target, replacement) {\n    replacement.isPatchedByReactHotLoader = true;\n    // React 16\n    if (target[lazyConstructor]) {\n        target[lazyConstructor] = replacement;\n    }\n    // React 17\n    else if (target._payload) {\n        target._payload._hotUpdated = true;\n        target._payload._result = replacement;\n    }\n    else {\n        console.error('could not update lazy component');\n    }\n};\nvar patched = function patched(fn) {\n    fn.isPatchedByReactHotLoader = true;\n    return fn;\n};\nvar patchLazyConstructor = function patchLazyConstructor(target) {\n    if (configuration.wrapLazy && !getLazyConstructor(target).isPatchedByReactHotLoader) {\n        var ctor = getLazyConstructor(target);\n        setLazyConstructor(target, function () {\n            return ctor().then(function (m) {\n                var C = resolveType(m.default);\n                // chunks has been updated - new hot loader process is taking a place\n                enterHotUpdate();\n                if (!React__default.forwardRef) {\n                    return {\n                        default: patched(function (props) {\n                            return React__default.createElement(AppContainer, null, React__default.createElement(C, props));\n                        })\n                    };\n                }\n                return {\n                    default: patched(\n                    // eslint-disable-next-line prefer-arrow-callback\n                    React__default.forwardRef(function HotLoaderLazyWrapper(props, ref) {\n                        return React__default.createElement(AppContainer, null, React__default.createElement(C, _extends({}, props, { ref: ref })));\n                    }))\n                };\n            });\n        });\n    }\n};\nvar updateLazy = function updateLazy(target, type) {\n    var ctor = getLazyConstructor(type);\n    if (getLazyConstructor(target) !== ctor) {\n        // just execute `import` and RHL.register will do the job\n        ctor();\n    }\n    patchLazyConstructor(target);\n    patchLazyConstructor(type);\n};\nvar updateMemo = function updateMemo(target, _ref) {\n    var type = _ref.type;\n    target.type = resolveType(type);\n};\nvar updateForward = function updateForward(target, _ref2) {\n    var render = _ref2.render;\n    target.render = render;\n};\nvar updateContext = function updateContext() {\n    // nil\n};\nvar getInnerComponentType = function getInnerComponentType(component) {\n    var unwrapper = component[UNWRAP_PROXY];\n    return unwrapper ? unwrapper() : component;\n};\nfunction haveEqualSignatures(prevType, nextType) {\n    try {\n        var prevSignature = getSignature(prevType);\n        var nextSignature = getSignature(nextType);\n        if (prevSignature === undefined && nextSignature === undefined) {\n            return true;\n        }\n        if (prevSignature === undefined || nextSignature === undefined) {\n            return false;\n        }\n        if (prevSignature.key !== nextSignature.key) {\n            return false;\n        }\n        // TODO: we might need to calculate previous signature earlier in practice,\n        // such as during the first time a component is resolved. We'll revisit this.\n        var prevCustomHooks = prevSignature.getCustomHooks();\n        var nextCustomHooks = nextSignature.getCustomHooks();\n        if (prevCustomHooks.length !== nextCustomHooks.length) {\n            return false;\n        }\n        for (var i = 0; i < nextCustomHooks.length; i++) {\n            if (!haveEqualSignatures(prevCustomHooks[i], nextCustomHooks[i])) {\n                return false;\n            }\n        }\n    }\n    catch (e) {\n        logger.error('React-Hot-Loader: error occurred while comparing hook signature', e);\n        return false;\n    }\n    return true;\n}\nvar areSignaturesCompatible = function areSignaturesCompatible(a, b) {\n    // compare signatures of two components\n    // non-equal component have to remount and there is two options to do it\n    // - fail the comparison, remounting all tree below\n    // - fulfill it, but set `_debugNeedsRemount` on a fiber to drop only local state\n    // the second way is not published yet, so going with the first one\n    if (!haveEqualSignatures(a, b)) {\n        logger.warn('⚛️🔥🎣 Hook order change detected: component', a, 'has been remounted');\n        return false;\n    }\n    return true;\n};\nvar compareRegistered = function compareRegistered(a, b) {\n    return getIdByType(a) === getIdByType(b) && getProxyByType(a) === getProxyByType(b) && areSignaturesCompatible(a, b);\n};\nvar areDeepSwappable = function areDeepSwappable(oldType, newType) {\n    var type = { type: oldType };\n    if (typeof oldType === 'function') {\n        return areSwappable(oldType, newType);\n    }\n    if (isForwardType(type)) {\n        return areDeepSwappable(oldType.render, newType.render);\n    }\n    if (isMemoType(type)) {\n        return areDeepSwappable(oldType.type, newType.type);\n    }\n    // that's not safe\n    // if (isLazyType(type)) {\n    //   return areDeepSwappable(oldType._ctor, newType._ctor)\n    // }\n    return false;\n};\nvar compareComponents = function compareComponents(oldType, newType, setNewType, baseType) {\n    var defaultResult = oldType === newType;\n    if (oldType && !newType || !oldType && newType || (typeof oldType === 'undefined' ? 'undefined' : _typeof(oldType)) !== (typeof newType === 'undefined' ? 'undefined' : _typeof(newType)) || getElementType(oldType) !== getElementType(newType) || 0) {\n        return defaultResult;\n    }\n    if (getIdByType(newType) || getIdByType(oldType)) {\n        if (!compareRegistered(oldType, newType)) {\n            return false;\n        }\n        defaultResult = true;\n    }\n    if (isForwardType({ type: oldType }) && isForwardType({ type: newType })) {\n        if (!compareRegistered(oldType.render, newType.render)) {\n            return false;\n        }\n        if (oldType.render === newType.render || areDeepSwappable(oldType, newType)) {\n            setNewType(newType);\n            return true;\n        }\n        return defaultResult;\n    }\n    if (isMemoType({ type: oldType }) && isMemoType({ type: newType })) {\n        if (!compareRegistered(oldType.type, newType.type)) {\n            return false;\n        }\n        if (oldType.type === newType.type || areDeepSwappable(oldType, newType)) {\n            if (baseType) {\n                // memo form different fibers, why?\n                if (baseType.$$typeof === newType.$$typeof) {\n                    setNewType(newType);\n                }\n                else {\n                    setNewType(newType.type);\n                }\n            }\n            else {\n                logger.warn('Please update hot-loader/react-dom');\n                if (isReactClass(newType.type)) {\n                    setNewType(newType);\n                }\n                else {\n                    setNewType(newType.type);\n                }\n            }\n            return true;\n        }\n        return defaultResult;\n    }\n    if (isLazyType({ type: oldType })) {\n        updateLazy(oldType, newType);\n        // no need to update\n        // setNewType(newType);\n        return defaultResult;\n    }\n    if (isContextType({ type: oldType })) {\n        // update provider\n        setNewType(newType);\n        return defaultResult;\n    }\n    if (typeof newType === 'function' && (defaultResult || newType !== oldType && areSignaturesCompatible(newType, oldType) && areSwappable(newType, oldType))) {\n        var unwrapFactory = newType[UNWRAP_PROXY];\n        var oldProxy = unwrapFactory && getProxyByType(unwrapFactory());\n        if (oldProxy) {\n            oldProxy.dereference();\n            updateProxyById(oldType[PROXY_KEY] || getIdByType(oldType), getInnerComponentType(newType));\n        }\n        else {\n            setNewType(newType);\n        }\n        return true;\n    }\n    return defaultResult;\n};\nvar knownPairs = new WeakMap();\nvar emptyMap$1 = new WeakMap();\nvar getKnownPair = function getKnownPair(oldType, newType) {\n    var pair = knownPairs.get(oldType) || emptyMap$1;\n    return pair.get(newType);\n};\nvar hotComponentCompare = function hotComponentCompare(oldType, preNewType, setNewType, baseType) {\n    var hotActive = hotComparisonOpen();\n    var newType = configuration.integratedResolver ? resolveType(preNewType) : preNewType;\n    // TODO: find out the root cause\n    // we could not use \"fast result\" here - go a full part to update a fiber.\n    // const knownType = getKnownPair(oldType, newType);\n    // if (knownType !== undefined) {\n    //   return knownType;\n    // }\n    var result = oldType === newType;\n    if (hotActive) {\n        // pre fail components which could not be merged\n        if (!isReloadableComponent(oldType) || !isReloadableComponent(newType) || isColdType(oldType) || isColdType(oldType) || !oldType || !newType || 0) {\n            return result;\n        }\n        result = compareComponents(oldType, newType, setNewType, baseType);\n        var pair = knownPairs.get(oldType) || new WeakMap();\n        pair.set(newType, result);\n        knownPairs.set(oldType, pair);\n        return result;\n    }\n    // result - true if components are equal, or were \"equal\" at any point in the past\n    return result || getKnownPair(oldType, newType) || false;\n};\n/* eslint-disable no-use-before-define */\nvar forceSimpleSFC = { proxy: { pureSFC: true } };\nvar hookWrapper = function hookWrapper(hook) {\n    var wrappedHook = function wrappedHook(cb, deps) {\n        if (configuration.reloadHooks && deps) {\n            var inputs = [].concat(deps);\n            // reload hooks which have changed string representation\n            if (configuration.reloadHooksOnBodyChange) {\n                inputs.push(String(cb));\n            }\n            if (\n            // reload hooks with dependencies\n            deps.length > 0 ||\n                // reload all hooks of option is set\n                configuration.reloadLifeCycleHooks && deps.length === 0) {\n                inputs.push(getHotGeneration());\n            }\n            return hook(cb, inputs);\n        }\n        return hook(cb, deps);\n    };\n    wrappedHook.isPatchedByReactHotLoader = true;\n    return wrappedHook;\n};\nvar noDeps = function noDeps() {\n    return [];\n};\nvar reactHotLoader = {\n    signature: function signature(type, key) {\n        var getCustomHooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noDeps;\n        addSignature(type, { key: key, getCustomHooks: getCustomHooks });\n        return type;\n    },\n    register: function register(type, uniqueLocalName, fileName) {\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var id = fileName + '#' + uniqueLocalName;\n        if (isCompositeComponent(type) && typeof uniqueLocalName === 'string' && uniqueLocalName && typeof fileName === 'string' && fileName) {\n            var proxy = getProxyById(id);\n            if (proxy && proxy.getCurrent() !== type) {\n                if (!configuration.IS_REACT_MERGE_ENABLED) {\n                    if (isTypeBlacklisted(type) || isTypeBlacklisted(proxy.getCurrent())) {\n                        logger.error('React-hot-loader: Cold component', uniqueLocalName, 'at', fileName, 'has been updated');\n                    }\n                }\n            }\n            if (configuration.onComponentRegister) {\n                configuration.onComponentRegister(type, uniqueLocalName, fileName);\n            }\n            if (configuration.onComponentCreate) {\n                configuration.onComponentCreate(type, getComponentDisplayName(type));\n            }\n            registerComponent(updateProxyById(id, type, options).get(), 2);\n            registerComponent(type);\n            increment();\n        }\n        if (isContextType({ type: type })) {\n            // possible options - Context, Consumer, Provider.\n            ['Provider', 'Consumer'].forEach(function (prop) {\n                var descriptor = Object.getOwnPropertyDescriptor(type, prop);\n                if (descriptor && descriptor.value) {\n                    updateFunctionProxyById(id + ':' + prop, descriptor.value, updateContext);\n                }\n            });\n            updateFunctionProxyById(id, type, updateContext);\n            increment();\n        }\n        if (isLazyType({ type: type })) {\n            updateFunctionProxyById(id, type, updateLazy);\n            increment();\n        }\n        if (isForwardType({ type: type })) {\n            reactHotLoader.register(type.render, uniqueLocalName + ':render', fileName, forceSimpleSFC);\n            updateFunctionProxyById(id, type, updateForward);\n            increment();\n        }\n        if (isMemoType({ type: type })) {\n            reactHotLoader.register(type.type, uniqueLocalName + ':memo', fileName, forceSimpleSFC);\n            updateFunctionProxyById(id, type, updateMemo);\n            increment();\n        }\n    },\n    reset: function reset() {\n        resetProxies();\n    },\n    preact: function preact(instance) {\n        preactAdapter(instance, resolveType);\n    },\n    resolveType: function resolveType$$1(type) {\n        return resolveType(type);\n    },\n    patch: function patch(React$$1, ReactDOM$$1) {\n        var typeResolver = resolveType;\n        /* eslint-disable no-console */\n        if (ReactDOM$$1 && !ReactDOM$$1.render) {\n            logger.error('React-Hot-Loader: broken state detected, please import React-Hot-Loader before react-dom, see https://github.com/gaearon/react-hot-loader/issues/1315');\n        }\n        if (ReactDOM$$1 && ReactDOM$$1.setHotElementComparator) {\n            ReactDOM$$1.setHotElementComparator(hotComponentCompare);\n            configuration.disableHotRenderer = configuration.disableHotRendererWhenInjected;\n            configuration.ignoreSFC = configuration.ignoreSFCWhenInjected;\n            configuration.IS_REACT_MERGE_ENABLED = true;\n            configuration.showReactDomPatchNotification = false;\n            configuration.integratedComparator = true;\n            if (ReactDOM$$1.setHotTypeResolver) {\n                configuration.integratedResolver = true;\n                typeResolver = resolveSimpleType;\n                ReactDOM$$1.setHotTypeResolver(resolveType);\n            }\n        }\n        // PATCH REACT METHODS\n        /* eslint-enable */\n        if (!React$$1.createElement.isPatchedByReactHotLoader) {\n            var originalCreateElement = React$$1.createElement;\n            // Trick React into rendering a proxy so that\n            // its state is preserved when the class changes.\n            // This will update the proxy if it's for a known type.\n            React$$1.createElement = function (type) {\n                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                    args[_key - 1] = arguments[_key];\n                }\n                return originalCreateElement.apply(undefined, [typeResolver(type)].concat(args));\n            };\n            React$$1.createElement.isPatchedByReactHotLoader = true;\n        }\n        if (!React$$1.cloneElement.isPatchedByReactHotLoader) {\n            var originalCloneElement = React$$1.cloneElement;\n            React$$1.cloneElement = function (element) {\n                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                var newType = element.type && typeResolver(element.type);\n                if (newType && newType !== element.type) {\n                    return originalCloneElement.apply(undefined, [_extends({}, element, {\n                            type: newType\n                        })].concat(args));\n                }\n                return originalCloneElement.apply(undefined, [element].concat(args));\n            };\n            React$$1.cloneElement.isPatchedByReactHotLoader = true;\n        }\n        if (!React$$1.createFactory.isPatchedByReactHotLoader) {\n            // Patch React.createFactory to use patched createElement\n            // because the original implementation uses the internal,\n            // unpatched ReactElement.createElement\n            React$$1.createFactory = function (type) {\n                var factory = React$$1.createElement.bind(null, type);\n                factory.type = type;\n                return factory;\n            };\n            React$$1.createFactory.isPatchedByReactHotLoader = true;\n        }\n        if (!React$$1.Children.only.isPatchedByReactHotLoader) {\n            var originalChildrenOnly = React$$1.Children.only;\n            // Use the same trick as React.createElement\n            React$$1.Children.only = function (children) {\n                return originalChildrenOnly(_extends({}, children, {\n                    type: typeResolver(children.type)\n                }));\n            };\n            React$$1.Children.only.isPatchedByReactHotLoader = true;\n        }\n        // PATCH REACT HOOKS\n        if (React$$1.useEffect && !React$$1.useEffect.isPatchedByReactHotLoader) {\n            React$$1.useEffect = hookWrapper(React$$1.useEffect);\n            React$$1.useLayoutEffect = hookWrapper(React$$1.useLayoutEffect);\n            React$$1.useCallback = hookWrapper(React$$1.useCallback);\n            React$$1.useMemo = hookWrapper(React$$1.useMemo);\n            // transform context for useContext\n            var useContext = React$$1.useContext;\n            React$$1.useContext = function (context) {\n                for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                    args[_key3 - 1] = arguments[_key3];\n                }\n                return useContext.apply(undefined, [typeResolver(context)].concat(args));\n            };\n        }\n        // reactHotLoader.reset()\n    }\n};\nvar openedModules = {};\nvar lastModuleOpened = '';\nvar getLastModuleOpened = function getLastModuleOpened() {\n    return lastModuleOpened;\n};\nvar hotModules = {};\nvar createHotModule = function createHotModule() {\n    return { instances: [], updateTimeout: 0 };\n};\nvar hotModule = function hotModule(moduleId) {\n    if (!hotModules[moduleId]) {\n        hotModules[moduleId] = createHotModule();\n    }\n    return hotModules[moduleId];\n};\nvar isOpened = function isOpened(sourceModule) {\n    return sourceModule && !!openedModules[sourceModule.id];\n};\nvar enter = function enter(sourceModule) {\n    if (sourceModule && sourceModule.id) {\n        lastModuleOpened = sourceModule.id;\n        openedModules[sourceModule.id] = true;\n    }\n    else {\n        logger.warn('React-hot-loader: no `module` variable found. Did you shadow a system variable?');\n    }\n};\nvar leave = function leave(sourceModule) {\n    if (sourceModule && sourceModule.id) {\n        delete openedModules[sourceModule.id];\n    }\n};\nvar createQueue = function createQueue() {\n    var runner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (a) {\n        return a();\n    };\n    var promise = void 0;\n    var queue = [];\n    var runAll = function runAll() {\n        var oldQueue = queue;\n        oldQueue.forEach(function (cb) {\n            return cb();\n        });\n        queue = [];\n    };\n    var add = function add(cb) {\n        if (queue.length === 0) {\n            promise = Promise.resolve().then(function () {\n                return runner(runAll);\n            });\n        }\n        queue.push(cb);\n        return promise;\n    };\n    return add;\n};\n/* eslint-disable camelcase, no-undef */\nvar requireIndirect =  true ? __webpack_require__ : undefined;\n/* eslint-enable */\nvar chargeFailbackTimer = function chargeFailbackTimer(id) {\n    return setTimeout(function () {\n        var error = 'hot update failed for module \"' + id + '\". Last file processed: \"' + getLastModuleOpened() + '\".';\n        logger.error(error);\n        logException({\n            toString: function toString() {\n                return error;\n            }\n        });\n        // 100 ms more \"code\" tolerant that 0, and would catch error in any case\n    }, 100);\n};\nvar clearFailbackTimer = function clearFailbackTimer(timerId) {\n    return clearTimeout(timerId);\n};\nvar createHoc = function createHoc(SourceComponent, TargetComponent) {\n    hoistNonReactStatic(TargetComponent, SourceComponent);\n    TargetComponent.displayName = 'HotExported' + getComponentDisplayName(SourceComponent);\n    return TargetComponent;\n};\nvar runInRequireQueue = createQueue();\nvar runInRenderQueue = createQueue(function (cb) {\n    if (ReactDOM.unstable_batchedUpdates) {\n        ReactDOM.unstable_batchedUpdates(cb);\n    }\n    else {\n        cb();\n    }\n});\nvar makeHotExport = function makeHotExport(sourceModule, moduleId) {\n    var updateInstances = function updateInstances(possibleError) {\n        if (possibleError && possibleError instanceof Error) {\n            console.error(possibleError);\n            return;\n        }\n        var module = hotModule(moduleId);\n        var deepUpdate = function deepUpdate() {\n            // force flush all updates\n            runInRenderQueue(function () {\n                enterHotUpdate();\n                var gen = getHotGeneration();\n                module.instances.forEach(function (inst) {\n                    return inst.forceUpdate();\n                });\n                if (configuration.trackTailUpdates) {\n                    var runLimit = 0;\n                    var checkTailUpdates = function checkTailUpdates() {\n                        setTimeout(function () {\n                            if (getHotGeneration() !== gen) {\n                                // we know that some components were updated, but not tracking which ones\n                                // even if their updates might be incorporated automatically (like lazy)\n                                // we dont know which one should be tracked, and which updates are important\n                                logger.warn('React-Hot-Loader: some components were updated out-of-bound. Updating your app to reconcile the changes.');\n                                // increment generator for cache-busting existing tree\n                                increment();\n                                deepUpdate();\n                            }\n                            else if (++runLimit < 5) {\n                                checkTailUpdates();\n                            }\n                        }, 16);\n                    };\n                    checkTailUpdates();\n                }\n            });\n        };\n        // require all modules\n        runInRequireQueue(function () {\n            try {\n                // webpack will require everything by this time\n                // but let's double check...\n                requireIndirect(moduleId);\n            }\n            catch (e) {\n                console.error('React-Hot-Loader: error detected while loading', moduleId);\n                console.error(e);\n            }\n        }).then(deepUpdate);\n    };\n    if (sourceModule.hot) {\n        // Mark as self-accepted for Webpack (callback is an Error Handler)\n        // Update instances for Parcel (callback is an Accept Handler)\n        sourceModule.hot.accept(updateInstances);\n        // Webpack way\n        if (sourceModule.hot.addStatusHandler) {\n            if (sourceModule.hot.status() === 'idle') {\n                sourceModule.hot.addStatusHandler(function (status) {\n                    if (status === 'apply') {\n                        clearExceptions();\n                        updateInstances();\n                    }\n                });\n            }\n        }\n    }\n    else {\n        logger.warn('React-hot-loader: Hot Module Replacement is not enabled');\n    }\n};\nvar hot = function hot(sourceModule) {\n    if (!sourceModule) {\n        // this is fatal\n        throw new Error('React-hot-loader: `hot` was called without any argument provided');\n    }\n    var moduleId = sourceModule.id || sourceModule.i || sourceModule.filename;\n    if (!moduleId) {\n        console.error('`module` provided', sourceModule);\n        throw new Error('React-hot-loader: `hot` could not find the `name` of the the `module` you have provided');\n    }\n    var module = hotModule(moduleId);\n    makeHotExport(sourceModule, moduleId);\n    clearExceptions();\n    var failbackTimer = chargeFailbackTimer(moduleId);\n    var firstHotRegistered = false;\n    // TODO: Ensure that all exports from this file are react components.\n    return function (WrappedComponent, props) {\n        clearFailbackTimer(failbackTimer);\n        // register proxy for wrapped component\n        // only one hot per file would use this registration\n        if (!firstHotRegistered) {\n            firstHotRegistered = true;\n            reactHotLoader.register(WrappedComponent, getComponentDisplayName(WrappedComponent), 'RHL' + moduleId);\n        }\n        return createHoc(WrappedComponent, function (_Component) {\n            inherits(ExportedComponent, _Component);\n            function ExportedComponent() {\n                classCallCheck(this, ExportedComponent);\n                return possibleConstructorReturn(this, _Component.apply(this, arguments));\n            }\n            ExportedComponent.prototype.componentDidMount = function componentDidMount() {\n                module.instances.push(this);\n            };\n            ExportedComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n                var _this2 = this;\n                if (isOpened(sourceModule)) {\n                    var componentName = getComponentDisplayName(WrappedComponent);\n                    logger.error('React-hot-loader: Detected AppContainer unmount on module \\'' + moduleId + '\\' update.\\n' + ('Did you use \"hot(' + componentName + ')\" and \"ReactDOM.render()\" in the same file?\\n') + ('\"hot(' + componentName + ')\" shall only be used as export.\\n') + 'Please refer to \"Getting Started\" (https://github.com/gaearon/react-hot-loader/).');\n                }\n                module.instances = module.instances.filter(function (a) {\n                    return a !== _this2;\n                });\n            };\n            ExportedComponent.prototype.render = function render() {\n                return React__default.createElement(AppContainer, props, React__default.createElement(WrappedComponent, this.props));\n            };\n            return ExportedComponent;\n        }(React.Component));\n    };\n};\nreactHotLoader.register(AppContainer, 'AppContainer', 'hot-dev');\nvar getProxyOrType = function getProxyOrType(type) {\n    var proxy = getProxyByType(type);\n    return proxy ? proxy.get() : type;\n};\nvar areComponentsEqual = function areComponentsEqual(a, b) {\n    return getProxyOrType(a) === getProxyOrType(b);\n};\nvar compareOrSwap = function compareOrSwap(oldType, newType) {\n    return hotComponentCompare(oldType, newType);\n};\nvar cold = function cold(type) {\n    blacklistByType(type);\n    return type;\n};\nvar configureComponent = function configureComponent(component, options) {\n    return setComponentOptions(component, options);\n};\nvar setConfig = function setConfig(config) {\n    return setConfiguration(config);\n};\nreactHotLoader.patch(React__default, ReactDOM);\nexports.default = reactHotLoader;\nexports.AppContainer = AppContainer;\nexports.hot = hot;\nexports.enterModule = enter;\nexports.leaveModule = leave;\nexports.areComponentsEqual = areComponentsEqual;\nexports.compareOrSwap = compareOrSwap;\nexports.cold = cold;\nexports.configureComponent = configureComponent;\nexports.setConfig = setConfig;\n\n\n//# sourceURL=webpack:///./node_modules/react-hot-loader/dist/react-hot-loader.development.js?");

/***/ }),

/***/ "./node_modules/react-hot-loader/dist/react-hot-loader.production.min.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/react-hot-loader/dist/react-hot-loader.production.min.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction _interopDefault(e) { return e && \"object\" == typeof e && \"default\" in e ? e.default : e; }\nObject.defineProperty(exports, \"__esModule\", { value: !0 });\nvar React = _interopDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nfunction AppContainer(e) { return AppContainer.warnAboutHMRDisabled && (AppContainer.warnAboutHMRDisabled = !0, console.error(\"React-Hot-Loader: misconfiguration detected, using production version in non-production environment.\"), console.error(\"React-Hot-Loader: Hot Module Replacement is not enabled.\")), React.Children.only(e.children); }\nAppContainer.warnAboutHMRDisabled = !1;\nvar hot = function e() { return e.shouldWrapWithAppContainer ? function (e) { return function (n) { return React.createElement(AppContainer, null, React.createElement(e, n)); }; } : function (e) { return e; }; };\nhot.shouldWrapWithAppContainer = !1;\nvar areComponentsEqual = function (e, n) { return e === n; }, setConfig = function () { }, cold = function (e) { return e; }, configureComponent = function () { };\nexports.AppContainer = AppContainer, exports.hot = hot, exports.areComponentsEqual = areComponentsEqual, exports.setConfig = setConfig, exports.cold = cold, exports.configureComponent = configureComponent;\n\n\n//# sourceURL=webpack:///./node_modules/react-hot-loader/dist/react-hot-loader.production.min.js?");

/***/ }),

/***/ "./node_modules/react-hot-loader/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-hot-loader/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nif (false) {}\nelse if (false) {}\nelse if (typeof window === 'undefined') {\n    // this is just server environment\n    module.exports = __webpack_require__(/*! ./dist/react-hot-loader.production.min.js */ \"./node_modules/react-hot-loader/dist/react-hot-loader.production.min.js\");\n}\nelse if (false) {}\nelse {\n    var evalAllowed = false;\n    var evalError = null;\n    try {\n        eval('evalAllowed = true');\n    }\n    catch (e) {\n        // eval not allowed due to CSP\n        evalError = e && e.message ? e.message : 'unknown reason';\n    }\n    // TODO: dont use eval to update methods. see #1273\n    // RHL needs setPrototypeOf to operate Component inheritance, and eval to patch methods\n    var jsFeaturesPresent = !!Object.setPrototypeOf;\n    if (!jsFeaturesPresent || !evalAllowed) {\n        // we are not in prod mode, but RHL could not be activated\n        console.warn('React-Hot-Loader is not supported in this environment:', [\n            !jsFeaturesPresent && \"some JS features are missing\",\n            !evalAllowed && \"`eval` is not allowed(\" + evalError + \")\"\n        ].join(','), '.');\n        module.exports = __webpack_require__(/*! ./dist/react-hot-loader.production.min.js */ \"./node_modules/react-hot-loader/dist/react-hot-loader.production.min.js\");\n    }\n    else {\n        module.exports = window.reactHotLoaderGlobal = __webpack_require__(/*! ./dist/react-hot-loader.development.js */ \"./node_modules/react-hot-loader/dist/react-hot-loader.development.js\");\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/react-hot-loader/index.js?");

/***/ }),

/***/ "./node_modules/react-hot-loader/root.js":
/*!***********************************************!*\
  !*** ./node_modules/react-hot-loader/root.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\nif (true) {\n    var hot = __webpack_require__(/*! ./index */ \"./node_modules/react-hot-loader/index.js\").hot;\n    if (true) {\n        var cache = __webpack_require__.c;\n        if (!module.parents || module.parents.length === 0) {\n            throw new Error('React-Hot-Loader: `react-hot-loader/root` is not supported on your system. ' +\n                'Please use `import {hot} from \"react-hot-loader\"` instead');\n        }\n        // access parent\n        var parent = cache[module.parents[0]];\n        if (!parent) {\n            throw new Error('React-Hot-Loader: `react-hot-loader/root` is not supported on your system. ' +\n                'Please use `import {hot} from \"react-hot-loader\"` instead');\n        }\n        // remove self from a cache\n        delete cache[module.i];\n        // setup hot for caller\n        exports.hot = hot(parent);\n    }\n    else {}\n}\nelse {}\nfunction fallbackHot() {\n    exports.hot = function (a) {\n        return a;\n    };\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/react-hot-loader/root.js?");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n    (function () {\n        'use strict';\n        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n        // nor polyfill, then a plain number is used for performance.\n        var hasSymbol = typeof Symbol === 'function' && Symbol.for;\n        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\n        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\n        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\n        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\n        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\n        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n        // (unstable) APIs that have been removed. Can we remove the symbols?\n        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\n        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\n        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\n        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\n        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\n        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\n        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\n        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\n        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n        function isValidElementType(type) {\n            return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n                type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n        }\n        function typeOf(object) {\n            if (typeof object === 'object' && object !== null) {\n                var $$typeof = object.$$typeof;\n                switch ($$typeof) {\n                    case REACT_ELEMENT_TYPE:\n                        var type = object.type;\n                        switch (type) {\n                            case REACT_ASYNC_MODE_TYPE:\n                            case REACT_CONCURRENT_MODE_TYPE:\n                            case REACT_FRAGMENT_TYPE:\n                            case REACT_PROFILER_TYPE:\n                            case REACT_STRICT_MODE_TYPE:\n                            case REACT_SUSPENSE_TYPE:\n                                return type;\n                            default:\n                                var $$typeofType = type && type.$$typeof;\n                                switch ($$typeofType) {\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                        }\n                    case REACT_PORTAL_TYPE:\n                        return $$typeof;\n                }\n            }\n            return undefined;\n        } // AsyncMode is deprecated along with isAsyncMode\n        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n        function isAsyncMode(object) {\n            {\n                if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n                }\n            }\n            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n        }\n        function isConcurrentMode(object) {\n            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n        }\n        function isContextConsumer(object) {\n            return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n            return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement(object) {\n            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef(object) {\n            return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n            return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n            return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n            return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n            return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n            return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n            return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n            return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        exports.AsyncMode = AsyncMode;\n        exports.ConcurrentMode = ConcurrentMode;\n        exports.ContextConsumer = ContextConsumer;\n        exports.ContextProvider = ContextProvider;\n        exports.Element = Element;\n        exports.ForwardRef = ForwardRef;\n        exports.Fragment = Fragment;\n        exports.Lazy = Lazy;\n        exports.Memo = Memo;\n        exports.Portal = Portal;\n        exports.Profiler = Profiler;\n        exports.StrictMode = StrictMode;\n        exports.Suspense = Suspense;\n        exports.isAsyncMode = isAsyncMode;\n        exports.isConcurrentMode = isConcurrentMode;\n        exports.isContextConsumer = isContextConsumer;\n        exports.isContextProvider = isContextProvider;\n        exports.isElement = isElement;\n        exports.isForwardRef = isForwardRef;\n        exports.isFragment = isFragment;\n        exports.isLazy = isLazy;\n        exports.isMemo = isMemo;\n        exports.isPortal = isPortal;\n        exports.isProfiler = isProfiler;\n        exports.isStrictMode = isStrictMode;\n        exports.isSuspense = isSuspense;\n        exports.isValidElementType = isValidElementType;\n        exports.typeOf = typeOf;\n    })();\n}\n\n\n//# sourceURL=webpack:///./node_modules/react-is/cjs/react-is.development.js?");

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nif (false) {}\nelse {\n    module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/react-is/index.js?");

/***/ }),

/***/ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.polyfill = void 0;\nfunction componentWillMount() {\n    // Call this.constructor.gDSFP to support sub-classes.\n    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n    if (state !== null && state !== undefined) {\n        this.setState(state);\n    }\n}\nfunction componentWillReceiveProps(nextProps) {\n    // Call this.constructor.gDSFP to support sub-classes.\n    // Use the setState() updater to ensure state isn't stale in certain edge cases.\n    function updater(prevState) {\n        var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n        return state !== null && state !== undefined ? state : null;\n    }\n    // Binding \"this\" is important for shallow renderer support.\n    this.setState(updater.bind(this));\n}\nfunction componentWillUpdate(nextProps, nextState) {\n    try {\n        var prevProps = this.props;\n        var prevState = this.state;\n        this.props = nextProps;\n        this.state = nextState;\n        this.__reactInternalSnapshotFlag = true;\n        this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    finally {\n        this.props = prevProps;\n        this.state = prevState;\n    }\n}\n// React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\nfunction polyfill(Component) {\n    var prototype = Component.prototype;\n    if (!prototype || !prototype.isReactComponent) {\n        throw new Error('Can only polyfill class components');\n    }\n    if (typeof Component.getDerivedStateFromProps !== 'function' &&\n        typeof prototype.getSnapshotBeforeUpdate !== 'function') {\n        return Component;\n    }\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Error if any of these lifecycles are present,\n    // Because they would work differently between older and newer (16.3+) versions of React.\n    var foundWillMountName = null;\n    var foundWillReceivePropsName = null;\n    var foundWillUpdateName = null;\n    if (typeof prototype.componentWillMount === 'function') {\n        foundWillMountName = 'componentWillMount';\n    }\n    else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n    }\n    if (typeof prototype.componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n    }\n    else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n    }\n    if (typeof prototype.componentWillUpdate === 'function') {\n        foundWillUpdateName = 'componentWillUpdate';\n    }\n    else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n    }\n    if (foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null) {\n        var componentName = Component.displayName || Component.name;\n        var newApiName = typeof Component.getDerivedStateFromProps === 'function'\n            ? 'getDerivedStateFromProps()'\n            : 'getSnapshotBeforeUpdate()';\n        throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n            componentName +\n            ' uses ' +\n            newApiName +\n            ' but also contains the following legacy lifecycles:' +\n            (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') +\n            (foundWillReceivePropsName !== null\n                ? '\\n  ' + foundWillReceivePropsName\n                : '') +\n            (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') +\n            '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' +\n            'https://fb.me/react-async-component-lifecycle-hooks');\n    }\n    // React <= 16.2 does not support static getDerivedStateFromProps.\n    // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n    // Newer versions of React will ignore these lifecycles if gDSFP exists.\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n        prototype.componentWillMount = componentWillMount;\n        prototype.componentWillReceiveProps = componentWillReceiveProps;\n    }\n    // React <= 16.2 does not support getSnapshotBeforeUpdate.\n    // As a workaround, use cWU to invoke the new lifecycle.\n    // Newer versions of React will ignore that lifecycle if gSBU exists.\n    if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n        if (typeof prototype.componentDidUpdate !== 'function') {\n            throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');\n        }\n        prototype.componentWillUpdate = componentWillUpdate;\n        var componentDidUpdate = prototype.componentDidUpdate;\n        prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {\n            // 16.3+ will not execute our will-update method;\n            // It will pass a snapshot value to did-update though.\n            // Older versions will require our polyfilled will-update value.\n            // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n            // Because for <= 15.x versions this might be a \"prevContext\" object.\n            // We also can't just check \"__reactInternalSnapshot\",\n            // Because get-snapshot might return a falsy value.\n            // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n            var snapshot = this.__reactInternalSnapshotFlag\n                ? this.__reactInternalSnapshot\n                : maybeSnapshot;\n            componentDidUpdate.call(this, prevProps, prevState, snapshot);\n        };\n    }\n    return Component;\n}\nexports.polyfill = polyfill;\n\n\n//# sourceURL=webpack:///./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js?");

/***/ }),

/***/ "./node_modules/shallowequal/index.js":
/*!********************************************!*\
  !*** ./node_modules/shallowequal/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//\nmodule.exports = function shallowEqual(objA, objB, compare, compareContext) {\n    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n    if (ret !== void 0) {\n        return !!ret;\n    }\n    if (objA === objB) {\n        return true;\n    }\n    if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n        return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n    // Test for A's keys different from B.\n    for (var idx = 0; idx < keysA.length; idx++) {\n        var key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n            return false;\n        }\n        var valueA = objA[key];\n        var valueB = objB[key];\n        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (ret === false || (ret === void 0 && valueA !== valueB)) {\n            return false;\n        }\n    }\n    return true;\n};\n\n\n//# sourceURL=webpack:///./node_modules/shallowequal/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./src/client/index.jsx":
/*!******************************!*\
  !*** ./src/client/index.jsx ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar ReactDOM = __importStar(__webpack_require__(/*! react-dom */ \"./node_modules/@hot-loader/react-dom/index.js\"));\nvar App_1 = __webpack_require__(/*! ../shared/App */ \"./src/shared/App.tsx\");\nwindow.addEventListener(\"load\", function () {\n    ReactDOM.hydrate(React.createElement(App_1.App, null), document.getElementById(\"root\"));\n});\n\n\n//# sourceURL=webpack:///./src/client/index.jsx?");

/***/ }),

/***/ "./src/shared/App.tsx":
/*!****************************!*\
  !*** ./src/shared/App.tsx ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.App = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar root_1 = __webpack_require__(/*! react-hot-loader/root */ \"./node_modules/react-hot-loader/root.js\");\nvar Header_1 = __webpack_require__(/*! ./Header */ \"./src/shared/Header.tsx\");\nvar AppComponent = function () {\n    return (react_1.default.createElement(\"div\", null,\n        react_1.default.createElement(Header_1.Header, null)));\n};\nexports.App = root_1.hot(AppComponent);\n\n\n//# sourceURL=webpack:///./src/shared/App.tsx?");

/***/ }),

/***/ "./src/shared/Header.tsx":
/*!*******************************!*\
  !*** ./src/shared/Header.tsx ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Header = void 0;\nvar root_1 = __webpack_require__(/*! react-hot-loader/root */ \"./node_modules/react-hot-loader/root.js\");\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar header_css_1 = __importDefault(__webpack_require__(/*! ./header.css */ \"./src/shared/header.css\"));\nfunction HeaderComponent() {\n    return (React.createElement(\"header\", null,\n        React.createElement(\"h1\", { className: header_css_1.default.example }, \"Hello React !!!!!\")));\n}\nexports.Header = root_1.hot(HeaderComponent);\n\n\n//# sourceURL=webpack:///./src/shared/Header.tsx?");

/***/ }),

/***/ "./src/shared/header.css":
/*!*******************************!*\
  !*** ./src/shared/header.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js??ref--5-1!./header.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/header.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\nif (true) {\n  if (!content.locals) {\n    module.hot.accept(\n      /*! !../../node_modules/css-loader/dist/cjs.js??ref--5-1!./header.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/header.css\",\n      function () {\n        var newContent = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js??ref--5-1!./header.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/header.css\");\n\n              newContent = newContent.__esModule ? newContent.default : newContent;\n\n              if (typeof newContent === 'string') {\n                newContent = [[module.i, newContent, '']];\n              }\n\n              update(newContent);\n      }\n    )\n  }\n\n  module.hot.dispose(function() { \n    update();\n  });\n}\n\nmodule.exports = exported;\n\n//# sourceURL=webpack:///./src/shared/header.css?");

/***/ })

})